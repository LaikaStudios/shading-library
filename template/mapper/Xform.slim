##
##  Copyright(c) 2010 Laika, developed under contract by mitchpraterLLC.
##  All rights reserved unless otherwise granted. This program or documentation
##  contains proprietary, confidential information and trade secrets of Laika
##  and/or mitchpraterLLC. Use of copyright notice does not imply publication.
##  
##  By possessing this software, you agree to the following terms and conditions.
##  You may not resell this software, but you may freely distribute it to others.
##  You may use it for whatever purposes you wish. There are no warranties of any
##  kind. You may make modifications, however any derivation may only be distributed
##  to others under the same freedoms granted to you herein, it must retain this
##  notice and agreement, and the modifications noted. We also ask that you make
##  such modifications available to Laika, mitchpraterLLC, or to the computer
##  graphics community as a whole through a public forum.
##
slim 1 extensions mprater {
  extensions laika vfx {

    templateV point Shuffle 0 {
        description {
            Shuffle the X, Y, and Z components.
        }

        parameter point input {
            detail mustvary "laika,Pcurrent"
        }

        parameter float Shuffle {
            label {Shuffle}
            description {
                The input XYZ values will be output in the selected arrangement.
            }
            provider variable
            detail uniform
            subtype selector
            range {
                "XYZ" 0
                "XZY" 1
                "YXZ" 2
                "YZX" 3
                "ZXY" 4
                "ZYX" 5
            }
            default 0
        }

        parameter point result {
            display hidden
            access output
        }

        RSLSource StaticFunction {
            void vfxShuffle (
                varying point   input;
                uniform float   Shuffle;

                output point    result;
            ) {
                if (Shuffle == 1)
                    result = point (input[0], input[2], input[1]);
                else if (Shuffle == 2)
                    result = point (input[1], input[0], input[2]);
                else if (Shuffle == 3)
                    result = point (input[1], input[2], input[0]);
                else if (Shuffle == 4)
                    result = point (input[2], input[0], input[1]);
                else if (Shuffle == 5)
                    result = point (input[2], input[1], input[0]);
                else
                    result = input;
            }
        }
    }

    templateV point Translate 2 {
        description {
            Translate the point: add offsets to the X, Y, and Z component values.
        }

        parameter point input {
            detail mustvary "laika,Pcurrent"
        }

        parameter point Translate {
            label {Translate}
            description {
            }
            provider variable
            detail varying
            default {0 0 0}
        }

        parameter point result {
            display hidden
            access output
        }

        RSLSource DynamicFunction {
            proc primvars {} {}
            proc function {} {
                generateBody {
                    set provider [getpropertyinfo Translate provider]
                    if {$provider == "variable" || $provider == "expression"} {
                        output "result = [getvar input] + vector transform (\"shader\", [getvar Translate]);"
                    } else {
                        output "result = [getvar input] + vector [getvar Translate];"
                    }
                }
            }
        }
    }

    templateV point Scale 2 {
        description {
            Scale the point: multiply the X, Y, and Z component values.
        }

        parameter point input {
            detail mustvary "laika,Pcurrent"
        }

        parameter float FScale {
            label {Overall Scale}
            description {
                A uniform scale value applied equally to all the components.
            }
            provider variable
            detail varying
            subtype slider
            range {-10 10}
            default 1
        }

        parameter point Scale {
            label {Scale}
            description {
                Individual (non-uniform) component scales.
            }
            provider variable
            detail varying
            default {1 1 1}
        }

        parameter point result {
            display hidden
            access output
        }

        RSLSource DynamicFunction {
            proc primvars {} {}
            proc function {} {
                generateBody {
                    set provider [getpropertyinfo Scale provider]
                    if {$provider == "variable" || $provider == "expression"} {
                        output "result = [getvar input] * transform (\"shader\", [getvar Scale]) * [getvar FScale];"
                    } else {
                        output "result = [getvar input] * [getvar Scale] * [getvar FScale];"
                    }
                }
            }
        }
    }

    templateV manifold MScale 2 {
        description {
            Scale the manifold: multiply the X, Y, and Z component values.
        }

        collection manifold input {
            parameter point Q {detail mustvary}
            parameter vector dQu {detail mustvary}
            parameter vector dQv {detail mustvary}

            detail mustvary "laika,Pcurrent"
        }

        parameter float FScale {
            label {Overall Scale}
            description {
                A uniform scale value applied equally to all the components.
            }
            provider variable
            detail varying
            subtype slider
            range {-10 10}
            default 1
        }

        parameter point Scale {
            label {Scale}
            description {
                Individual (non-uniform) component scales.
            }
            provider variable
            detail varying
            default {1 1 1}
        }

        collection manifold result {
            display hidden
            access output
            parameter point M {access output}
            parameter vector dMu {access output}
            parameter vector dMv {access output}
        }

        RSLSource DynamicFunction {
            proc primvars {} {}
            proc function {} {
                generateBody {
output "
                    varying point   S;
"
                    set provider [getpropertyinfo Scale provider]
                    if {$provider == "variable" || $provider == "expression"} {
                        output "S = transform (\"shader\", [getvar Scale]);"
                    } else {
                        output "S = [getvar Scale];"
                    }
output "
                    M = [getvar Q] * S * [getvar FScale];
                    dMu = [getvar dQu] * S * [getvar FScale];
                    dMv = [getvar dQv] * S * [getvar FScale];
"
                }
            }
        }
    }

    templateV manifold_s Shear 0 {
        description {
            Shear the space along the selected axis.
            Useful for projecting certain kinds of 2d textures into three dimensions.
            Wood grain is the perfect example.
        }

        parameter string Axis {
            label {Axis}
            description {
                The Axis to Shear the space in: this axis value will be added
                to the other two axes.
            }
            detail varying
            subtype selector
            range {
                "Z" Z
                "Y" Y
                "X" X
            }
            default Z
        }

        parameter point Q {
            label {Manifold}
            description {
                The Manifold you want to Shear.
            }
            detail mustvary "laika,Pref"
        }

        parameter manifold_s M {
            display hidden
            access output
        }

        RSLInclude {manifold.h}

        RSLSource StaticFunction {
            void vfxShear (
                uniform string  Axis;
                varying point   Q;

                output manifold_s   M;
            ) {
                if (Axis == "Z")
                    M->Set(point (Q[0]+Q[2], Q[1]+Q[2], Q[2]));
                else if (Axis == "Y")
                    M->Set(point (Q[0]+Q[1], Q[1], Q[2]+Q[1]));
                else
                    M->Set(point (Q[0], Q[1]+Q[0], Q[2]+Q[0]));
            }
        }
    }

  }
}
