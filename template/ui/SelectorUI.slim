##
##  Copyright(c) 2010-2011 Laika, developed under contract by mitchpraterLLC.
##  All rights reserved unless otherwise granted. This program or documentation
##  contains proprietary, confidential information and trade secrets of Laika
##  and/or mitchpraterLLC. Use of copyright notice does not imply publication.
##  
##  By possessing this software, you agree to the following terms and conditions.
##  You may not resell this software, but you may freely distribute it to others.
##  You may use it for whatever purposes you wish. There are no warranties of any
##  kind. You may make modifications, however any derivation may only be distributed
##  to others under the same freedoms granted to you herein, it must retain this
##  notice and agreement, and the modifications noted. We also ask that you make
##  such modifications available to Laika, mitchpraterLLC, or to the computer
##  graphics community as a whole through a public forum.
##
#
#   Creates parameters that can then be selected from.
#
#   From AddPrimAttrOpt.slim, which is based on Pixar's layerui2.slim 
#
slim 1 extensions mprater {
  extensions laika vfx {

    customui SelectorUI {
        classification addschildren

        TclTkSource {
            variable size;
            variable icon;
            variable parent;        # an array accessed by canvas id containing the collection parameter.  
            variable canvasList;    # used so undo/redo works between window destroys
            variable labelCanvasIdMap;  # contains the canvas and id of the label parameter.

            #
            # Gets the auto extension given a parameter or collection
            # that was created with an auto extension: the last _ and
            # everything after it. Removed the _ so we get just a number.
            #
            proc getAutoExt {coll} {
                set collName [$coll GetName]
                set extIndex [expr [string last "_" $collName] + 1]
                return [string range $collName $extIndex end]
            }

            #
            #   Create the Tk components that aren't parameters or collections;
            #   specifically, the Add button and other necessary UI components.
            #
            #   createLayer will be called by the Add button to create a layer collection,
            #   along with whatever parameters are needed,
            #
            #   and rebuildCanvas will display the collection parameters using Tk.
            #
            proc BuildUI {container recommendedWidth args} {
                variable size
                variable icon
                variable parent
                variable canvasList

                if ![info exists icon] {
                    set icon(delete) [::RAT::GetImage layer-close.gif]
                    set icon(deleteGlow) [::RAT::GetImage layer-close-glo.gif]
                }

                if ![info exists size] {
                    set size(LayerRowHeight) 24
                    set size(AddButtonHeight) 36
                    set size(LayerRowHalfHeight) 12
                    set size(InterRowSpaceHeight) 0
                    set size(DeleteIconWidth) 10
                    set size(LabelWidth) 20
                    set size(LayerWidth) 30
                    set size(ConnectionWidth) 40
                }

                #
                # recommendedWidth is the width of the entire window.
                # The customui is presented in a canvas.
                # The canvas is divided into rows of windows, a row per layer.
                # The first row is the button row and is always present.
                # Layer rows are added/subtracted dynamically via this GUI.
                # A Layer row is comprised of a collection of icons and standard tk widgets as follows:
                #   layer delete icon
                #   editable layer label
                #
                set size(recommendedWidth) $recommendedWidth
                set size(frameWidth) $recommendedWidth

                set canvas $container
                set id [string range $canvas [expr [string last . $canvas] + 1] end]

                #
                # Look for parent collection.
                #
                set i [lsearch $args -parent] 
                if {$i == -1} return; #error

                set parent($id) [lindex $args [incr i]]

                canvas $canvas -width $size(recommendedWidth)
                set canvasList($id) $canvas

                # Button frame in which the add button will exist.
                frame $canvas.bf

                # Tk Add button to create a new set of layer collection/parameters
                button $canvas.bf.add -text "    Add Choice   " \
                    -command [::RAT::PackageCode [namespace code "createLayer $canvas $id"]]

                set addDescription "Adds a new Choice. Each choice has an editable Label,\nwhich is used to select it based on the Choice parameter's\nvalue. It also has a default value, or can be connected to\na function, in which case the connection's value is returned."
                ::RAT::AddBalloon $canvas.bf.add "$addDescription" 0

                # Pack it into the frame
                pack $canvas.bf.add -side left -padx 4

                # Create the canvas window (frame) in which the above items will be drawn
                $canvas create window 0 0 -window $canvas.bf -anchor nw

                # Display the layer components
                if [catch "rebuildCanvas $canvas $id" msg] {
                    ::RAT::LogMsg ERROR $msg
                }

                # Tk buttons for removing a layer
                $canvas bind delete <Enter> \
                    "$canvas itemconfigure current -image $icon(deleteGlow)"
                $canvas bind delete <Leave> \
                    "$canvas itemconfigure current -image $icon(delete)"
                $canvas bind delete <1> \
                    [::RAT::PackageCode [namespace code "deleteCmd $canvas $id"]]

                return [$canvas cget -height]
            }

            #
            # Slim MsgHandler for the user changing the label parameter value.
            # Finds the proper canvas and id for the parameter and then calls
            # changeLabel to handle the rest.
            #
            proc changeLabelCB {obj} {
                variable labelCanvasIdMap

                if ![info exists labelCanvasIdMap($obj)] {
                    ::RAT::LogMsg NOTICE "No labelCanvasIdMap entry for $obj."
                    return
                }

                set ci $labelCanvasIdMap($obj)
                set canvas [lindex $ci 0]
                set id [lindex $ci 1]

                changeLabel $canvas $id
            }

            #
            # Updates the selection parameter's range of values and current selection
            # when the user changes a label or removes a choice.
            #
            proc changeLabel {canvas id} {
                variable parent

                # get the selection parameter
                set app [$parent($id) GetAppearance]
                set selectParamName "SelectorUI_Selection"
                set selectParam [$app GetProperties -name $selectParamName]

                # get the list of current labels
                set labelList {}
                set selectRange {}

                set colls [$parent($id) GetChildren]
                set ncolls [llength $colls]
                for {set i 0} {$i < $ncolls} {incr i} {
                    set layerCollection [lindex $colls $i]
                    set layerParameters [$layerCollection GetChildren]

                    set labelParam [lindex $layerParameters 0]
                    set labelValue [$labelParam GetValue]

                    # set the input parameter label to the corresponding label value.
                    # this is so we can find the selected input based on the selection parameter value.
                    set inputParam [lindex $layerParameters 1]
                    $inputParam SetLabel $labelValue

                    lappend labelList $labelValue
                    lappend selectRange $labelValue $labelValue
                }

                # set the selection parameter range to the new set of labels
                $selectParam SetRange $selectRange

                # if the currect choice no longer exists, set the selection parameter to ""
                set selectionChoice [$selectParam GetValue]
                if {[lsearch -exact $labelList $selectionChoice] == -1} {
                    $selectParam SetValue ""
                }

                ::RAT::RedrawAppearanceUI $canvas
            }

            #
            #   createLayer creates these parameters when the Add button is pushed:
            #
            #   SelectionUI_Collection#auto
            #       SelectionUI_Label#auto
            #       SelectionUI_Input#auto
            #
            # paramType is userdata set in the template.
            # #auto is some kind of magic that will be expanded to _uniqueNumber.
            #
            proc createLayer {canvas id {redraw 1}} {
                variable parent
                variable labelCanvasIdMap
                
                set c $parent($id)

                # Get appearance handle.
                set app [$c GetAppearance]

                # Get the connection type from the template.
                set paramType [$c GetUserData paramType]

                # Create the layer collection and get the autoExt-ension.
                set paramCollection [$c NewCollection void SelectorUI_Collection#auto]
                set autoExt [getAutoExt $paramCollection]

                # Create the layer's label parameter.
                # When the label's value is changed, the selection parameter's range must be updated.
                set paramLabel [$paramCollection NewSlimAttribute string SelectorUI_Label$autoExt]
                    $paramLabel SetDefaultValue $autoExt
                    $paramLabel SetMsgHandler SetValue "
                        ::Slim::CustomUI::laika::SelectorUI::changeLabelCB %obj
                    "

                # Create the layer input connection.
                # Be sure to label it with the label value so we can find it later.
                if {$paramType == "shadingcomponent"} {
                    set paramInput [$paramCollection NewCollection $paramType SelectorUI_Input$autoExt]
                        $paramInput SetLabel $autoExt
                        $paramInput SetDetail mustvary
                        set paramColor [$paramInput NewParameter color SelectorUI_Color$autoExt]
                            $paramColor SetDetail mustvary
                        foreach aov [::aovGetAOVNames current] {
                            set paramAOV [$paramInput NewParameter color SelectorUI_${aov}$autoExt]
                                $paramAOV SetDetail mustvary
                                $paramAOV SetValueProvider connection
                                $paramAOV SetDefaultValue 0
                        }
                } else {
                    set paramInput [$paramCollection NewParameter $paramType SelectorUI_Input$autoExt]
                        $paramInput SetLabel ${paramType}$autoExt
                        $paramInput SetDetail varying
                        if {$paramType == "float"} {
                            $paramInput SetDefaultValue 0
                        } elseif {$paramType == "string"} {
                            $paramInput SetSubtype "file"
                            $paramInput SetDefaultValue ""
                        } else {
                            $paramInput SetDefaultValue {0 0 0}
                        }
                }

                # Place the new collection at the end of the list.
                set children [lreplace [$c GetChildren] end end]
                set children [linsert $children end $paramCollection]
                $c SetChildren $children
                if $redraw {
                    ::RAT::RedrawAppearanceUI $canvas
                }

                # Save the canvas and id for the label parameter.
                set labelCanvasIdMap($paramLabel) [list $canvas $id]

                # Update the Selection range.
                changeLabel $canvas $id

                $app DirtyMaster
            }

            #
            #   Use Tk to display the layer components created by clicking the Add button.
            #
            proc rebuildCanvas {canvas id} {
                variable size
                variable icon
                variable parent
                variable labelCanvasIdMap

                set c $parent($id)

                # Get appearance handle.
                set app [$c GetAppearance]

                # Get the layer collections.
                set colls [$c GetChildren]

                # Set initial row height.
                set y [expr 3 + $size(LayerRowHeight)]

                # For each layer collection... 
                set ncolls [llength $colls]
                for {set i 0} {$i < $ncolls} {incr i} {
                    set layerCollection [lindex $colls $i]
                    set layerParameters [$layerCollection GetChildren]
                    set labelParam [lindex $layerParameters 0]
                    set inputParam [lindex $layerParameters 1]

                    set y [expr $y + $size(InterRowSpaceHeight) + 1]
                    set w $canvas.row$i
                    catch "destroy $w"
                    set ymid [expr $y + $size(LayerRowHalfHeight)]

                    $canvas create image $size(DeleteIconWidth) $ymid \
                        -image $icon(delete) -anchor w -tags "delete delete$i widget"

                    frame $w -width $size(frameWidth) -height $size(LayerRowHeight)

                    set wlabel $w.label
                    set winput $w.input

                    $labelParam BuildDefaultWidget $canvas $wlabel \
                        $size(LabelWidth) $size(LayerRowHeight)
                    $inputParam BuildDefaultWidget $canvas $winput \
                        $size(ConnectionWidth) $size(LayerRowHeight)

                    pack $wlabel -side left
                    pack $winput -side right -fill x -expand 1

                    $canvas create window $size(LayerWidth) $y -window $w \
                        -anchor nw -tags "layer$i widget"

                    set y [expr $y + $size(LayerRowHeight) + 1]
                    
                    set labelCanvasIdMap($labelParam) [list $canvas $id]
                }

                $canvas configure -height $y
            }

            #
            # deleteCmd:
            #   Called via canvas binding, so look at current canvas object
            #   to determine the object to act upon.
            #
            proc deleteCmd {canvas id} {
                variable parent
                set tags [$canvas gettags current];     # Assume tags are "delete delete$i widget"
                set row [string range [lindex $tags 1] 6 end]
                set docmd [::RAT::PackageCode [namespace code "removeLayer $canvas $id $row"]]

                set parameters [$parent($id) GetChildren]
                set elementP [lindex $parameters $row]
                set c [$elementP GetChildren]

                set cmdkey [::RAT::GetCmdStackKeyFromWindow $canvas]
                ::RAT::JournalCmd -doit "$docmd" -undoit "" -title "Remove Layer" -cmdkey $cmdkey
            }

            #
            # Remove the parameter collection and params.
            #
            proc removeLayer {canvas id index} {
                variable parent
                variable labelCanvasIdMap

                set coll $parent($id)

                # find the parameter layer collection
                set parms [$coll GetChildren]
                set p [lindex $parms $index]

                # remove the entry in labelCanvasIdMap
                set labelParam [lindex [$p GetChildren] 0]
                unset labelCanvasIdMap($labelParam)

                # remove the whole layer collection
                $coll RemoveChild $p

                # update the Selection range
                changeLabel $canvas $id

                # mark shader as dirty and redraw the canvas
                set app [$coll GetAppearance]
                $app DirtyMaster
                ::RAT::RedrawAppearanceUI $canvas
            }
        }
    }

  }
}
