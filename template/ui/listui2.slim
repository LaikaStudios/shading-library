##
## Copyright (c) 2003 PIXAR.  All rights reserved.  This program or
## documentation contains proprietary confidential information and trade
## secrets of PIXAR.  Reverse engineering of object code is prohibited.
## Use of copyright notice is precautionary and does not imply
## publication.
##
##                      RESTRICTED RIGHTS NOTICE
##
## Use, duplication, or disclosure by the Government is subject to the
## following restrictions:  For civilian agencies, subparagraphs (a) through
## (d) of the Commercial Computer Software--Restricted Rights clause at
## 52.227-19 of the FAR; and, for units of the Department of Defense, DoD
## Supplement to the FAR, clause 52.227-7013 (c)(1)(ii), Rights in
## Technical Data and Computer Software.
##
## Pixar
## 1200 Park Ave
## Emeryville, CA 94608
##
## ----------------------------------------------------------------------------
#
# ListUI2: a custom ui to support the combination of
#   an arbitrary list of scalar functions.
#
#   For ListUI2 collections we assert that the children 
#   of the collection is an ordered list of collection nodes each of which
#   represents a combinable value.  A combinable collection is comprised 
#   of a fixed (but optional) number of elements following this naming
#   convention:
#   element#auto
#       CLEn#auto  (enables/disables this element)
#       CLOp#auto (optional)  (selects the combining operation with other layers)
#       CLFilt#auto (optional) (filters the result of the connection)
#       CLCnx#auto (provides the key connection point for this element)
#   The containing collection's label is used to specify options governing the 
#   construction of the GUI.  The format is standard tcl-list of -token value pairs:
#   -connectiontype slimtype
#   -defaultconnection pixar,Diffuse
#   -connectionvalue (default value for connection)
#   -filtertype slimtype|none
#   -filtervalue default value for filtertype
#   -optype none|standard
#   -buttonlabel mylabel
#   -buttondescription "This is what clicking this button will do."
#
#   $Revision: #1 $
#
#   lakia,mprater
#       Added +/- Op
#       Added inputLabel and inputPrefix userdata.
#       Added -buttondescription balloon help.
#       Added -provider option
#
slim 1 extensions pixardb {
 extensions pixar pxsl {

  customui ListUI2 {
    classification addschildren
    TclTkSource {
        variable parents;   # an array accessed by canvas id containing
                            # the collection parameter.  
        # constants used in the layout of the GUI.
        variable icons; # an array of move, moveGlow, delete, deleteGlow
        variable sizes; # an array of sizes indexed by: 
            # kLayerRowHeight, kInterRowSpace
            # recommendedWidth
            # frameWidth
            # strwidgetWidth

        variable ddState; # currentSelection, mouseState, ddSource, ddTarget
        variable canvasList; #used so undo/redo works between window destroys


        #
        # Gets the auto extension given an object
        # that was created with an auto extension.
        #
        proc getAutoExt {obj} {
            set objName [$obj GetName]
            set extIndex [string last "_" $objName]
            incr extIndex 
            return [string range $objName $extIndex end]
        }


        proc BuildUI {container recommendedWidth args} {
            variable parents
            variable canvasList
            variable sizes
            variable icons
            variable ddState
            if ![info exists icons] {
                set sizes(kLayerRowHeight) 32
                set sizes(kLayerRowHalfHeight) 15
                set sizes(kInterRowSpaceHeight) 4
                set sizes(kInterRowSpaceWidth) 126
                set sizes(kLabelEditOffsetX) 46
                set sizes(kLabelEditOffsetY) 4
                set sizes(kIconWidth) 26
                set sizes(kMoveIconX) 1
                set sizes(kDeleteIconX) 20
                set sizes(kLayerLabelX) 34
                set sizes(kLayerFrameX) 75
                set sizes(kDraggerWidth) [expr $sizes(kLayerFrameX) - 5]

                set icons(move) [::RAT::GetImage layer-move.gif]
                set icons(moveGlow) [::RAT::GetImage layer-move-glo.gif]
                set icons(delete) [::RAT::GetImage layer-close.gif]
                set icons(deleteGlow) [::RAT::GetImage layer-close-glo.gif]

                set ddState(currentSelection) {}
                set ddState(mouseState) {}
                set ddState(ddSource) {}
                set ddState(ddTarget) {}
            }
            # recommendedWidth is the width of the entire window
            # our customui is presented in a canvas.
            # The canvas is divided into rows of windows
            # a row per layer. The first row is the button row and is
            # always present.  Layer rows are added/subtracted dynamically
            # vis this GUI.  A Layer row is comprised of
            # a collection of icons and standard tk widgets as follows:
            #   layer drag/drop handle icon
            #   layer delete icon
            #   editable label
            #   standard widgets for
            #   enabled/disable checkbutton
            #   combining operator menubutton
            #   optional float multiplier vslider
            #   $type connection point
            #
            set sizes(recommendedWidth) $recommendedWidth
            set sizes(frameWidth) [expr $recommendedWidth - $sizes(kLayerFrameX)]
            set sizes(strwidgetWidth) 30; # characters

            set canvas $container
            set id [string range $canvas [expr [string last . $canvas] + 1] end]

            # look for parent parameter - a collection.
            set i [lsearch $args -parent] 
            if { $i == -1 } return; #error
            set parents($id) [lindex $args [incr i]]
            array set options [$parents($id) GetLabel]
            canvas $canvas -width $sizes(recommendedWidth) -height $sizes(kLayerRowHeight); # height is adjusted below
            set canvasList($id) $canvas
            
            # static button area
            frame $canvas.buttons -width $sizes(recommendedWidth) \
                -height [expr $sizes(kLayerRowHeight) -1]
            if ![info exists options(-buttonlabel)] {
                set options(-buttonlabel) "Add Element"
            }
            button $canvas.buttons.add \
                -text $options(-buttonlabel) \
                -command [::RAT::PackageCode [namespace code "createLayer $canvas $id"]]
            if [info exists options(-buttondescription)] {
                ::RAT::AddBalloon $canvas.buttons.add $options(-buttondescription) 0
            }
            pack $canvas.buttons.add -padx 2 -pady 2
            $canvas create window 0 0 -window $canvas.buttons -anchor nw \
                -tags "button-win move-1"
            if [catch "rebuildCanvas $canvas $id" msg] {
                ::RAT::LogMsg ERROR $msg
            }
            $canvas bind move <1> \
                [::RAT::PackageCode [namespace code "ddDragBegin $canvas $id %x %y"]]
            $canvas bind move <Enter> \
                [::RAT::PackageCode [namespace code "enterMove $canvas"]]
            $canvas bind move <Leave>  \
                [::RAT::PackageCode [namespace code "leaveMove $canvas"]]
            
            $canvas bind delete <Enter> \
                "$canvas itemconfigure current -image $icons(deleteGlow)"
            $canvas bind delete <Leave> \
                "$canvas itemconfigure current -image $icons(delete)"
            $canvas bind delete <1> \
                [::RAT::PackageCode [namespace code "deleteCmd $canvas $id"]]

            $canvas bind label <Enter> \
                "$canvas itemconfigure current -fill red"
            $canvas bind label <Leave> \
                "$canvas itemconfigure current -fill black"
            $canvas bind label <1> \
                [::RAT::PackageCode [namespace code "editLabel $canvas $id"]]

            bind $canvas <B1-Motion> [::RAT::PackageCode [namespace code "ddDrag $canvas $id %x %y"]]
            bind $canvas <Any-ButtonRelease-1> [::RAT::PackageCode [namespace code "ddDrop $canvas $id %x %y"]]
            bind $canvas <Enter> [::RAT::PackageCode [namespace code "enterCanvas $canvas $id %x %y"]]  
            bind $canvas <Leave> [::RAT::PackageCode [namespace code "leaveCanvas $canvas $id %x %y"]]
            return [$canvas cget -height]
        }

        proc createSpacer {canvas y row} {
            if 0 {
                # useful for visual debugging...
                variable sizes
                set ymax [expr $y + $sizes(kInterRowSpaceHeight)]
                $canvas create rectangle 1 $y $sizes(kInterRowSpaceWidth) $ymax \
                    -tags "space space$row widget"
            }
        }

        proc rebuildCanvas {canvas id} {
            variable parents
            variable sizes
            variable icons

            $canvas delete widget
            set y [expr 3 + $sizes(kLayerRowHeight)]
            set parameters [$parents($id) GetChildren]
            set nRows [llength $parameters]
            for {set i 0} {$i < $nRows} {incr i} {
                set layerCollection [lindex $parameters $i]
                set layerParameters [$layerCollection GetChildren]
                createSpacer $canvas $y $i
                set y [expr $y + $sizes(kInterRowSpaceHeight) + 1]
                set w $canvas.row$i
                catch "destroy $w"
                set ymid [expr $y + $sizes(kLayerRowHalfHeight)]
                $canvas create image $sizes(kMoveIconX) $ymid \
                    -image $icons(move) -anchor w -tags "move move$i widget"
                $canvas create image $sizes(kDeleteIconX) $ymid \
                    -image $icons(delete) -anchor w -tags "delete delete$i widget"
                $canvas create text $sizes(kLayerLabelX) $ymid \
                    -anchor w -tags "label label$i widget" \
                    -text [$layerCollection GetLabel]
                frame $w -width $sizes(frameWidth) -height $sizes(kLayerRowHeight)
                set ip 0
                set lastp [expr [llength $layerParameters] -1]
                foreach param $layerParameters {
                    set wp $w.p$ip
                    $param BuildDefaultWidget $canvas $wp 100 $sizes(kLayerRowHeight)
                    if {$ip < $lastp} {
                        pack $wp -side left
                        incr ip
                    } else {
                        pack $wp -side left -fill x -expand 1
                    }
                }
                $canvas create window $sizes(kLayerFrameX) $y -window $w \
                    -anchor nw -tags "layer$i widget"
                set y [expr $y + $sizes(kLayerRowHeight) + 1]
            }
            if {$nRows > 0} {
                # add one extra space widget to designate drop after last
                createSpacer $canvas $y $nRows
                set y [expr $y + 2 + $sizes(kInterRowSpaceHeight)]
            }
            $canvas configure -height $y
        }

        # editLabel:
        # called via bindings - look at the current canvas selection to
        # determine the object to act upon.
        proc editLabel {canvas id} {
            variable sizes
            variable parents
            focus $canvas; update
            set xy [$canvas coords current]
            set x [lindex $xy 0]
            set y [lindex $xy 1]
            set tags [$canvas gettags current]; # assume tags are "label label$i widget"
            set row [string range [lindex $tags 1] 5 end]
            entry $canvas.e -width 12
            set collection $parents($id)
            set children [$collection GetChildren]
            set parm [lindex $children $row]
            $canvas.e insert 0 [$parm GetLabel]
            $canvas.e selection range 0 end
            bind $canvas.e <Return> "focus $canvas"
            bind $canvas.e <FocusOut> [::RAT::PackageCode \
                [namespace code "setLabel $canvas $canvas.e $parm $row"]]
            $canvas create window $x $y -window $canvas.e -anchor w -tags edittext
            focus $canvas.e
        }

        proc setLabel {canvas entry parm row} {
            set txt [$entry get]
            $parm SetLabel $txt
            $canvas itemconfigure label$row -text $txt
            $canvas delete edittext
            destroy $entry
        }

        proc createLayer {canvas id {redraw 1}} {
            variable parents
            set c $parents($id)

            # See comments at top describing option names
            array set options [$c GetLabel]

            if ![info exists options(-elementdesc)] {
                RAT::LogMsg ERROR "ListUI2: requires -elementdesc in collection label"
                return
            }

            set inputLabel [$c GetUserData "inputLabel"]
            if {$inputLabel == ""} {
                set inputLabel "LI"
            }

            set inputPrefix [$c GetUserData "inputPrefix"]
            if {$inputPrefix == ""} {
                set inputPrefix "LI"
            }

            set layerCollection [$c NewCollection void LC#auto]
            set autoExt [getAutoExt $layerCollection]
            $layerCollection SetLabel "_____"

            foreach pd $options(-elementdesc) {
                catch "unset popts"
                array set popts $pd
                if ![info exists popts(-type)] {
                    RAT::LogMsg ERROR "ListUI2: parameter requires -type"
                    continue
                }
                set type $popts(-type)

                set newp [$layerCollection NewParameter $type ${inputPrefix}_${autoExt}]
                $newp SetLabel ${inputLabel}_${autoExt}

                foreach {tok val} $pd {
                    #if [string equal $tok -type] continue
                    switch -- $tok {
                        -subtype {
                            $newp SetSubtype $val
                        }
                        -default {
                            $newp SetDefaultValue $val
                        }
                        -range {
                            $newp SetRange $val
                        }
                        -detail {
                            eval $newp SetDetail $val
                        }
                        -provider {
                            eval $newp SetValueProvider $val
                        }
                    }
                }
                # special ListUI2 subtypes
                if [info exists popts(-subtype)] {
                    switch $popts(-subtype) {
                        combineOp {
                            $newp SetSubtype selector
                            $newp SetRange { 
                                "+" plus
                                "-" minus
                                "+/-" plusminus
                                "x" times
                            }
                            $newp SetDefaultValue $popts(-default)
                        }
                        file {
                            $newp SetSubtype file
                            $newp SetDefaultValue $popts(-default)
                        }
                    }
                }
            }   
            if $redraw {
                ::RAT::RedrawAppearanceUI $canvas
            }
        }

        # deleteCmd:
        #   called via canvas binding. Look at current canvas object
        #   to determine the object to act upon.
        proc deleteCmd {canvas id} {
            variable parents
            set tags [$canvas gettags current]; # assume tags are "delete delete$i widget"
            set row [string range [lindex $tags 1] 6 end]
            set docmd [::RAT::PackageCode [namespace code "removeLayer $canvas $id $row"]]
            set parameters [$parents($id) GetChildren]
            set layer [lindex $parameters $row]

            set label [$layer GetLabel]
            set c [$layer GetChildren]
            set type [$parents($id) GetName]
            set encapsulation $label

            foreach p $c {
                set provider [$p GetValueProvider]
                if [string equal $provider connection] {
                    lappend encapsulation [list connection [$p GetConnection]]
                } else {
                    lappend encapsulation [list $provider [$p GetValue]]
                }
            }
            set undocmd [::RAT::PackageCode [namespace code "reinsertLayer $canvas $id $row $encapsulation"]]
            set cmdkey [::RAT::GetCmdStackKeyFromWindow $canvas]
                ::RAT::JournalCmd -doit "$docmd" \
                -undoit "$undocmd" \
                -title "Remove Layer" \
                -cmdkey $cmdkey
        }

        proc removeLayer {canvas id index} {
            variable parents
            set coll $parents($id)
            set parms [$coll GetChildren]
            set p [lindex $parms $index]
            $coll RemoveChild $p; # remove and delete
            ::RAT::RedrawAppearanceUI $canvas
        }

        # reinsertLayer:
        # called after undoing a delete operation
        proc reinsertLayer {canvas id index encapsulation} {
            variable parents
            set old [::RAT::SetJournalingState 0]
            # first add a new layer, then reorder
            createLayer $canvas $id 0; # don't redraw
            # the new layer should be the first
            set layers [$parents($id) GetChildren]
            set layer [lindex $layers 0]
            set label [lindex $encapsulation 0]
            $layer SetLabel $label
            set parameters [$layer GetChildren]
            set i 1
            foreach p $parameters {
                set pen [lindex $encapsulation $i]; incr i;
                foreach {provider value} $pen {
                    $p SetValueProvider $provider
                    if [string equal connection $provider] {
                        $p SetConnection $value
                    } else {
                        $p SetValue $value
                    }
                }
            }
            moveLayer $canvas $id 0 $index
            ::RAT::RedrawAppearanceUI $canvas
            ::RAT::SetJournalingState $old
        }

        # move parameters at row $startIndex to $moveIndex
        proc moveLayer {canvas id startIndex moveIndex} {
            variable parents
            if {$startIndex > $moveIndex} {
                incr moveIndex
            }
            if {$startIndex != $moveIndex} {
                set old [::RAT::SetJournalingState 0]
                # Simply reorder the children of the parent. Indices
                # are assumed to be rows...
                set parameters [$parents($id) GetChildren]
                set tclattr [lindex $parameters $startIndex]
                set parameters [lreplace $parameters $startIndex $startIndex]
                set parameters [linsert $parameters $moveIndex $tclattr]
                $parents($id) SetChildren $parameters
                if [winfo exists $canvas] {
                    rebuildCanvas $canvas $id
                }
                ::RAT::SetJournalingState $old
            }
        }

        proc enterMove canvas {
            variable icons
            $canvas itemconfigure [$canvas find withtag current] -image $icons(moveGlow)
        }

        proc leaveMove canvas {
            variable icons  
            $canvas itemconfigure [$canvas find withtag current] -image $icons(move)
        }

        proc ddCreateMoveWidgets {canvas id y {showDrop 1}} {
            variable ddState
            variable parents
            variable icons
            variable sizes
            set parameters [$parents($id) GetChildren]
            set element [lindex $parameters $ddState(currentSelection)]
            set label [$element GetLabel]
            set xy [$canvas coords move$ddState(currentSelection)]
            set xoffset [expr [lindex $xy 0] + 4]
            $canvas create line $xoffset $y [expr $xoffset + $sizes(kDraggerWidth)] $y \
                -fill white -width 2 -tags {hlLine active} 
            $canvas create image $xoffset $y \
                -image $icons(moveGlow) \
                -anchor w \
                -tags {hlLine active}   
            $canvas create text [expr $xoffset + 32] $y \
                -text $label \
                -anchor w \
                -tags {hlLine active}
            if $showDrop {
                set offy [expr [lindex $xy 1] + 18]
                $canvas create line [lindex $xy 0] $offy [expr [lindex $xy 0] + 100] $offy \
                    -fill lightblue -width 6 -tags {hlDrop} 
            }
            $canvas raise active
        }
        
        proc ddDragBegin {canvas id x y} {
            variable ddState
            variable parents

            set ddState(x) $x
            set ddState(y) $y
            set ddState(moved) 0

            set tags [$canvas gettags current]
            set row [string range [lindex $tags 1] 4 end]; # assumed tags: move move$i ...
            set ddState(currentSelection) $row
            set ddState(moveSelection) $ddState(currentSelection)  
            set ddState(mouseState) $ddState(currentSelection) 
            ddCreateMoveWidgets $canvas $id $y
        }

        proc ddDrag {canvas id x y} {
            variable ddState
            variable sizes

            set tags [$canvas gettags current]
            if {-1 == [lsearch $tags move]} {
                set ddState(currentSelection) {}
                return
            }
            if { $x > $ddState(x) + 2 || $y > $ddState(y) + 2 } {
                set ddState(moved) 1
            } elseif { $x < $ddState(y) - 2 || $y < $ddState(y) - 2 } {
                set ddState(moved) 1
            }
            if {$ddState(currentSelection)  != {}} {
                if {[$canvas find withtag hlLine] == {}} {
                    return
                }
                set xy [$canvas coords active]
                set widgety [lindex $xy 1]
                if {$widgety == {}} {
                    set widgety 0
                }
                set dx 0
                if {$y <= 0} {
                    set dy [expr -$widgety]
                } else {
                    set dy [expr $y - $widgety]
                }
                $canvas move active $dx $dy
                
                set selectionlist [$canvas find \
                    overlapping 0 [expr $y + 26] \
                    32 [expr $y - 26]]
                
                set tags [$canvas itemcget [lindex $selectionlist 0] -tags]
                if {[lindex $tags 0] != "move"} {
                    set tempxy [$canvas coords [lindex $selectionlist 1]]
                    set offy [expr [lindex $tempxy 1] -18]
                } else {
                    set tempxy [$canvas coords [lindex $selectionlist 0]]
                    set offy [expr [lindex $tempxy 1] + 18]
                }

                #use move tag to determine if we are in the middle of the list
                #use the button-win tag to determine if we are at top of list
                
                if {[lindex $tags 0] == "move"} {
                    set ddState(moveSelection) [string range [lindex $tags 1] 4 end]
                    $canvas delete hlDrop
                    $canvas create line [lindex $tempxy 0] $offy \
                        [expr [lindex $tempxy 0] + $sizes(kDraggerWidth)] $offy \
                        -fill lightblue -width 6 -tags {hlDrop} 
                    
                    $canvas raise active        
                } elseif {[lindex $tags 0] == "button-win"} {
                    set tags2 [$canvas itemcget [lindex $selectionlist 1] -tags]
                    if {[lindex $tags2 0] == "move"} {
                        set ddState(moveSelection) [string range [lindex $tags 1] 4 end]
                        $canvas delete hlDrop
                        $canvas create line [lindex $tempxy 0] $offy \
                            [expr [lindex $tempxy 0] + $sizes(kDraggerWidth)] $offy \
                            -fill lightblue -width 6 -tags {hlDrop} 
                        
                        $canvas raise active
                    }       
                }
            }
        }

        #handle button1 release events
        proc ddDrop {canvas id x y} {
            variable ddState
            set ddState(mouseState) {}
            if {[$canvas find withtag active] == {}} {
                return
            } else {
                #do move
                if {$ddState(currentSelection) != $ddState(moveSelection) && \
                    $ddState(currentSelection) != [expr $ddState(moveSelection) + 1]} {
                set docmd [::RAT::PackageCode [namespace code \
                    "moveLayer $canvas $id $ddState(currentSelection) $ddState(moveSelection)"]]
                if {$ddState(currentSelection)  < $ddState(moveSelection)} {
                    set src $ddState(moveSelection)
                    set dst [expr $ddState(currentSelection)  - 1]
                } else {
                    set src [expr $ddState(moveSelection) + 1]
                    set dst $ddState(currentSelection) 
                }
                set undocmd [::RAT::PackageCode \
                    [namespace code "moveLayer $canvas $id $src $dst"]]
                set cmdkey [::RAT::GetCmdStackKeyFromWindow $canvas]
                ::RAT::JournalCmd -doit "$docmd" \
                    -undoit "$undocmd" \
                    -title "Move Layer" \
                    -cmdkey $cmdkey
                }
                $canvas delete hlLine
                $canvas delete hlDrop 
            }
        }

        # used for drag/drop of adaptors (undo cancel)
        proc enterCanvas {canvas id x y} {
            variable ddState
            if {$ddState(mouseState) != {}} {
                set ddState(currentSelection) $ddState(mouseState)
                ddCreateMoveWidgets $canvas $id $y 0
            }
        }
        # used for drag/drop of adaptors (allows mouse to move outside of window
        # and cause a cancel action)
        proc leaveCanvas {canvas id x y} {
            variable ddState
            if {$ddState(currentSelection) != {} && $ddState(mouseState) != {}} {
                $canvas delete hlLine
                $canvas delete hlDrop
                set ddState(mouseState) $ddState(currentSelection)
                set ddState(currentSelection) {}
            }
        }
    }
  }

 }
}
