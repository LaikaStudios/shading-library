##
##  Copyright(c) 2014 Laika, developed under contract by mitchpraterLLC.
##  All rights reserved unless otherwise granted. This program or documentation
##  contains proprietary, confidential information and trade secrets of Laika
##  and/or mitchpraterLLC. Use of copyright notice does not imply publication.
##  
##  By possessing this software, you agree to the following terms and conditions.
##  You may not resell this software, but you may freely distribute it to others.
##  You may use it for whatever purposes you wish. There are no warranties of any
##  kind. You may make modifications, however any derivation may only be distributed
##  to others under the same freedoms granted to you herein, it must retain this
##  notice and agreement, and the modifications noted. We also ask that you make
##  such modifications available to Laika, mitchpraterLLC, or to the computer
##  graphics community as a whole through a public forum.
##
slim 1 extensions mprater {
  extensions laika vfx {

    templateV multiple floatTexture 1 {
        description {
            Access a single texture file or set of files generated by Mari or Mudbox.
        }

        parameter float Enable {
            label {Enable}
            description {
                Enable texture access or not.
            }
            detail varying
            subtype switch
            default 1
        }
        parameter coshader Enable_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string File {
            label File
            description {
                Specifies a Single file, or the set of files produced by Mari or Mudbox.
                When specifying a set of Mari or Mudbox files, choose any file name in the atlas
                (the collection of texture files obeying the file naming and texture mapping
                conventions they produce), then replace the map id portion of the file name with "_MAPID_".
                _MAPID_ will be substituted internally with the correct value to access the correct
                texture file based on their texture mapping convention.
            }
            provider variable
            detail varying
            subtype texture
            default ""
        }
        parameter coshader File_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string FileType {
            label {File Type}
            description {
                Selects the type of file access to use.
                "Single" accesses the texture File, and maps it onto the 0-1 range of the Manifold
                parameter's x and y coordinates.
                "Mari" uses the texture atlasing scheme produced by Mari.
                "Mudbox" uses the texture atlasing scheme produced by Mudbox.
            }
            subtype selector
            range {
                "Single" Single
                "Mari"   mari
                "Mudbox" mudbox
            }
            default mari
        }
        parameter coshader FileType_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter float Channel {
            label {Output Value}
            description {
                Selects what Value to output.
            }
            subtype selector
            range {
                "R" 0
                "G" 1
                "B" 2
                "RGB Luma" 5
                "min R,G,B" 6
                "max R,G,B" 7
            }
            default 0
        }
        parameter coshader Channel_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string Filter {
            label Filter
            description {
                box is fast, but has artifacts.
                lagrangian is designed for speed and detail preservation.
                radial-bspline is designed for filtering bump/displacement textures.
                gaussian produces inherently smooth results but is expensive.
                disk is optimized for large blur sizes, is free of mipmap artifacts, but is very expensive.
                eliptical weighted average does anisotropic filtering, based on the
                surface orientation relative to the camera, so is the most "correct" result.
            }
            subtype selector
            range {
                "box" box
                "lagrangian" lagrangian
                "radial-bspline" radial-bspline
                "gaussian" gaussian
                "disk"     disk
                "eliptical weighted average" ewa
            }
            default box
        }
        parameter coshader Filter_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter float Blur {
            label Blur
            description {
                The size of the filter to use when accessing the texture data.
                Specified in 0 to 1 texture space (1 = the entire texture).
            }
            detail varying
            subtype slider
            range {0 .1 .001}
            default 0
        }
        parameter coshader Blur_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter float Lerp {
            label Lerp
            description {
                Selects whether to interpolate between adjacent resolutions
                of a multi-resolution texture in order to smooth the
                transition between resolutions.
            }
            subtype switch
            default 0
        }
        parameter coshader Lerp_Co_ {
            display hidden
            default {}
            value {}
        }

        collection manifold Manifold {
            label {Manifold}
            description {
                The space the texture will be mapped to.
            }
            parameter point Q { detail mustvary }
            parameter vector dQu { detail mustvary }
            parameter vector dQv { detail mustvary }
            detail mustvary "laika,UV" inline
        }

        parameter float FlipV {
            label {Flip V}
            description {
                Flip the V orientation of the texture.
            }
            subtype switch
            default 0
        }

        parameter float UseFilterregion {
            label {Use Filterregion}
            description {
                Use filterregion texture access.
            }
            subtype switch
            default 0
        }

        collection void Adjust {
            label {Value Adjustments}
            description {
                These controls alter the texture data after it's been read from the texture file.
                The data modifications are performed top-down in the order the parameters are listed.
            }

            parameter float InputConversion {
                label {Input Conversion}
                description {
                    Selects what conversion to perform on the texture data
                    immediately after it's read.
                }
                subtype selector
                range {
                    "None" 0
                    "Linear -> sRGB" 1
                    "sRGB -> Linear" 2
                }
                default 0
            }
            parameter coshader InputConversion_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float Invert {
                label {Invert}
                description {
                    Change the texture data values from 0 to 1 and vice versa.
                    When checked, the texture value will instead become 1-textureValue.
                }
                detail varying
                subtype switch
                default 0
            }
            parameter coshader Invert_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float ZeroValue {
                label {Zero Value}
                description {
                    This texure value will instead be output as 0:
                    the texture data is remapped so that this value will become 0.
                    Equivalent to the Linear template functioning.
                }
                detail varying
                subtype slider
                range {0 1}
                default 0
            }
            parameter coshader ZeroValue_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float OneValue {
                label {One Value}
                description {
                    This texure value will instead be output as 1:
                    the texture data is remapped so that this value will become 1.
                    Equivalent to the Linear template functioning.
                }
                detail varying
                subtype slider
                range {0 1}
                default 1
            }
            parameter coshader OneValue_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float RemapZero {
                label "Remap Zero"
                description {
                    The current texture value is remapped so a value of 0 will instead become this value.
                    Equivalent to the Mix template functioning.
                }
                detail varying
                subtype slider
                range {0 1}
                default 0
            }
            parameter coshader RemapZero_Co_ {
                display hidden
                default {}
                value {}
            }
            parameter float RemapOne {
                label "Remap One"
                description {
                    The current texture value is remapped so a value of 1 will instead become this value.
                    Equivalent to the Mix template functioning.
                }
                detail varying
                subtype slider
                range {0 1}
                default 1
            }
            parameter coshader RemapOne_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float Contrast {
                label {Contrast}
                description {
                    Scale the contrast by this amount.
                    Works by adjusting the mix between the texture value and the average texture value.
                    When Contrast = 0, the average value is produced.
                    When Contrast = 1, the texture value is produced.
                }
                detail varying
                subtype slider
                range {0 2}
                default 1
            }
            parameter coshader Contrast_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float Clamp {
                label {Clamp}
                description {
                    Selects if and how the data will be limited to the 0 to 1 range.
                }
                subtype selector
                range {
                    "Off"       0
                    "Clamp"     1
                    "Declip"    2
                    "Linear Step 7.5%"  3
                    "Linear Step 15%"   4
                    "Smoothstep"        5
                    "Rational Step"     6
                }
                default 0
            }
            parameter coshader Clamp_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float Scale {
                label {Scale}
                description {
                    Multiply the result by this value.
                }
                detail varying
                default 1
            }
            parameter coshader Scale_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float OutputConversion {
                label {Output Conversion}
                description {
                    Selects what conversion to perform on the adjusted result.
                }
                subtype selector
                range {
                    "None" 0
                    "Linear -> sRGB" 1
                    "sRGB -> Linear" 2
                }
                default 0
            }
            parameter coshader OutputConversion_Co_ {
                display hidden
                default {}
                value {}
            }
        }

        collection void Missing {
            label {Missing}
            description {
                Controls what to do when the texture file is not found.
            }

            parameter float IgnoreMissing {
                label {Ignore Missing}
                description {
                    When on, no warning for a missing texture will be issued,
                    and the Value, Average, and Alpha values will be used in its place.
                }
                subtype switch
                default 1
            }
            parameter coshader IgnoreMissing_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float MissingValue {
                label {Value}
                description {
                    Output this Value if the texture file is missing.
                }
                detail varying
                subtype slider
                range {0 1}
                default 0
            }
            parameter coshader MissingValue_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float MissingAverage {
                label {Average}
                description {
                    Output this Average if the texture file is missing.
                }
                detail varying
                subtype slider
                range {0 1}
                default 0
            }
            parameter coshader MissingAverage_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float MissingAlpha {
                label {Alpha}
                description {
                    Output this Alpha if the texture file is missing.
                }
                detail varying
                subtype slider
                range {0 1}
                default 0
            }
            parameter coshader MissingAlpha_Co_ {
                display hidden
                default {}
                value {}
            }
        }

        parameter float outValue {
            display hidden
            label {Value}
            access output
        }

        parameter float outAverage {
            display hidden
            label {Average}
            access output
        }

        parameter float outAlpha {
            display hidden
            label {Alpha}
            access output
        }


        RSLInclude {color.h}
        RSLInclude {pattern/texture.h}
        RSLInclude {coreV7/override.h}

        RSLSource DynamicFunction {
            proc primvars {} {}
            proc function {} {
                generateBody {

                    set overrideParam "Enable"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "File"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "FileType"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Channel"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Filter"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Blur"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Lerp"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "InputConversion"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Invert"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "ZeroValue"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "OneValue"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "RemapZero"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "RemapOne"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Contrast"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Clamp"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Scale"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "OutputConversion"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "IgnoreMissing"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "MissingValue"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "MissingAverage"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "MissingAlpha"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

output "
                    outValue = 0;
                    outAverage = 0;
                    outAlpha = 0;

                    if (gridalways( abs(_Enable) == 0 )) return;

                    varying color   texValue = color 0;
                    varying color   texAverage = color 0;

                    if (_IgnoreMissing)
                    {
                        outValue = _MissingValue;
                        outAverage = _MissingAverage;
                        outAlpha = _MissingAlpha;

                        texValue = color _MissingValue;
                        texAverage = color _MissingAverage;
                    }

                    if (_File == \"\") return;


                    varying float   x = xcomp( [getvar Q] );
                    varying float   y = ycomp( [getvar Q] );

                    if ([getvar FlipV]) y = 1.0 - y;


                    // Mari or Mudbox texture atlas.
                    if (_FileType != \"Single\")
                    {
                        textureatlasRead( _File, _FileType, _Channel, x, y,
                            [getvar UseFilterregion],
                            _IgnoreMissing,
                            _Filter,
                            _Blur,
                            texValue, texAverage, outAlpha
                        );
                    }


                    // Single texture file.
                    else
                    {
                        textureRead( _File, _Channel, x, 1-y,
                            [getvar UseFilterregion],
                            _IgnoreMissing,
                            _Filter,
                            _Blur,
                            _Lerp,
                            texValue, texAverage, outAlpha
                        );
                    }

                    if (_Channel < 3)
                    {
                        outValue = texValue\[_Channel\];
                        outAverage = texAverage\[_Channel\];
                    }
                    else if (_Channel == 3)
                    {
                        outValue = outAlpha;
                        outAverage = texAverage\[0\];
                    }
                    else if (_Channel == 4)
                    {
                        outValue = texValue\[0\];
                        outAverage = texAverage\[0\];
                    }
                    else if (_Channel == 5)
                    {
                        outValue = colorRGBToLuma( texValue );
                        outAverage = colorRGBToLuma( texAverage );
                    }
                    else if (_Channel == 6)
                    {
                        outValue = min( texValue\[0\], texValue\[1\], texValue\[2\] );
                        outAverage = min( texAverage\[0\], texAverage\[1\], texAverage\[2\] );
                    }
                    else if (_Channel == 7)
                    {
                        outValue = max( texValue\[0\], texValue\[1\], texValue\[2\] );
                        outAverage = max( texAverage\[0\], texAverage\[1\], texAverage\[2\] );
                    }

                    //
                    // Process the data.
                    //
                    if (_InputConversion == 1)
                    {
                        outValue = colorSRGBEncode( outValue );
                        outAverage = colorSRGBEncode( outAverage );
                    }

                    else if (_InputConversion == 2)
                    {
                        outValue = colorSRGBDecode( outValue );
                        outAverage = colorSRGBDecode( outAverage );
                    }

                    outValue = mix( outValue, float 1 - outValue, _Invert );
                    outAverage = mix( outAverage, float 1 - outAverage, _Invert );

                    outValue = linear( _ZeroValue, _OneValue, outValue );
                    outAverage = linear( _ZeroValue, _OneValue, outAverage );

                    outValue = mix( _RemapZero, _RemapOne, outValue );
                    outAverage = mix( _RemapZero, _RemapOne, outAverage );

                    outValue = mix( outAverage, outValue, _Contrast );

                    // Clamping.
                    {
                        uniform float   _clamp = gridmax( _Clamp );

                        if (_clamp == 1)
                        {
                            outValue = clamp( outValue, float 0, float 1 );
                            outAverage = clamp( outAverage, float 0, float 1 );
                        }

                        else if (_clamp == 2)
                        {
                            outValue = colorDeclip( outValue );
                            outAverage = colorDeclip( outAverage );
                        }

                        else if (_clamp == 3)
                        {
                            outValue = linear( 0, 1, outValue );
                            outValue = mathLinearSpline( .075, .075, outValue );

                            outAverage = linear( 0, 1, outAverage );
                            outAverage = mathLinearSpline( .075, .075, outAverage );
                        }

                        else if (_clamp == 4)
                        {
                            outValue = linear( 0, 1, outValue );
                            outValue = mathLinearSpline( .15, .15, outValue );

                            outAverage = linear( 0, 1, outAverage );
                            outAverage = mathLinearSpline( .15, .15, outAverage );
                        }

                        else if (_clamp == 5)
                        {
                            outValue = _smoothstep( 0, 1, outValue );
                            outAverage = _smoothstep( 0, 1, outAverage );
                        }

                        else if (_clamp == 6)
                        {
                            outValue = linear( 0, 1, outValue );
                            outValue = mathRationalSpline( 0.5, outValue );

                            outAverage = linear( 0, 1, outAverage );
                            outAverage = mathRationalSpline( 0.5, outAverage );
                        }
                    }

                    outValue *= _Scale;
                    outAverage *= _Scale;

                    if (_OutputConversion == 1)
                    {
                        outValue = colorSRGBEncode( outValue );
                        outAverage = colorSRGBEncode( outAverage );
                    }

                    else if (_OutputConversion == 2)
                    {
                        outValue = colorSRGBDecode( outValue );
                        outAverage = colorSRGBDecode( outAverage );
                    }

                    outValue   *= _Enable;
                    outAverage *= _Enable;
                    outAlpha   *= _Enable;
"
                }
            }
        }
    }


    templateV multiple colorTexture 1 {
        description {
            Access a single texture file or set of files generated by Mari or Mudbox.
        }

        parameter float Enable {
            label {Enable}
            description {
                Enable texture access or not.
            }
            detail varying
            subtype switch
            default 1
        }
        parameter coshader Enable_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string File {
            label File
            description {
                Specifies a Single file, or the set of files produced by Mari or Mudbox.
                When specifying a set of Mari or Mudbox files, choose any file name in the atlas
                (the collection of texture files obeying the file naming and texture mapping
                conventions they produce), then replace the map id portion of the file name with "_MAPID_".
                _MAPID_ will be substituted internally with the correct value to access the correct
                texture file based on their texture mapping convention.
            }
            provider variable
            detail varying
            subtype texture
            default ""
        }
        parameter coshader File_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string FileType {
            label {File Type}
            description {
                Selects the type of file access to use.
                "Single" accesses the texture File, and maps it onto the 0-1 range of the Manifold
                parameter's x and y coordinates.
                "Mari" uses the texture atlasing scheme produced by Mari.
                "Mudbox" uses the texture atlasing scheme produced by Mudbox.
            }
            subtype selector
            range {
                "Single" Single
                "Mari"   mari
                "Mudbox" mudbox
            }
            default mari
        }
        parameter coshader FileType_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter float Channel {
            label {Output Value}
            description {
                Selects what Value to output.
            }
            subtype selector
            range {
                "RGB" 4
                "R" 0
                "G" 1
                "B" 2
                "RGB Luma" 5
                "min R,G,B" 6
                "max R,G,B" 7
            }
            default 4
        }
        parameter coshader Channel_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string Filter {
            label Filter
            description {
                box is fast, but has artifacts.
                lagrangian is designed for speed and detail preservation.
                radial-bspline is designed for filtering bump/displacement textures.
                gaussian produces inherently smooth results but is expensive.
                disk is optimized for large blur sizes, is free of mipmap artifacts, but is very expensive.
                eliptical weighted average does anisotropic filtering, based on the
                surface orientation relative to the camera, so is the most "correct" result.
            }
            subtype selector
            range {
                "box" box
                "lagrangian" lagrangian
                "radial-bspline" radial-bspline
                "gaussian" gaussian
                "disk"     disk
                "eliptical weighted average" ewa
            }
            default box
        }
        parameter coshader Filter_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter float Blur {
            label Blur
            description {
                The size of the filter to use when accessing the texture data.
                Specified in 0 to 1 texture space (1 = the entire texture).
            }
            detail varying
            subtype slider
            range {0 .1 .001}
            default 0
        }
        parameter coshader Blur_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter float Lerp {
            label Lerp
            description {
                Selects whether to interpolate between adjacent resolutions
                of a multi-resolution texture in order to smooth the
                transition between resolutions.
            }
            subtype switch
            default 0
        }
        parameter coshader Lerp_Co_ {
            display hidden
            default {}
            value {}
        }

        collection manifold Manifold {
            label {Manifold}
            description {
                The space the texture will be mapped to.
            }
            parameter point Q { detail mustvary }
            parameter vector dQu { detail mustvary }
            parameter vector dQv { detail mustvary }
            detail mustvary "laika,UV" inline
        }

        parameter float FlipV {
            label {Flip V}
            description {
                Flip the V orientation of the texture.
            }
            subtype switch
            default 0
        }

        parameter float UseFilterregion {
            label {Use Filterregion}
            description {
                Use filterregion texture access.
            }
            subtype switch
            default 0
        }

        collection void Adjust {
            label {Value Adjustments}
            description {
                These controls alter the texture data after it's been read from the texture file.
                The data modifications are performed top-down in the order the parameters are listed.
            }

            parameter float InputConversion {
                label {Input Conversion}
                description {
                    Selects what conversion to perform on the texture data
                    immediately after it's read.
                }
                subtype selector
                range {
                    "None" 0
                    "Linear -> sRGB" 1
                    "sRGB -> Linear" 2
                }
                default 0
            }
            parameter coshader InputConversion_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float Invert {
                label {Invert}
                description {
                    Change the texture data values from black to white and vice versa.
                    When checked, each texture value will instead become 1-textureValue.
                }
                detail varying
                subtype switch
                default 0
            }
            parameter coshader Invert_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter color ZeroValue {
                label {Zero Value}
                description {
                    This texure value will instead be output as 0:
                    the texture data is remapped so that this value will become 0.
                    Equivalent to the Linear template functioning.
                }
                detail varying
                default {0 0 0}
            }
            parameter coshader ZeroValue_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter color OneValue {
                label {One Value}
                description {
                    This texure value will instead be output as 1:
                    the texture data is remapped so that this value will become 1.
                    Equivalent to the Linear template functioning.
                }
                detail varying
                default {1 1 1}
            }
            parameter coshader OneValue_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter color RemapZero {
                label "Remap Zero"
                description {
                    The current texture value is remapped so a value of 0 will instead become this value.
                    Equivalent to the Mix template functioning.
                }
                detail varying
                default {0 0 0}
            }
            parameter coshader RemapZero_Co_ {
                display hidden
                default {}
                value {}
            }
            parameter color RemapOne {
                label "Remap One"
                description {
                    The current texture value is remapped so a value of 1 will instead become this value.
                    Equivalent to the Mix template functioning.
                }
                detail varying
                default {1 1 1}
            }
            parameter coshader RemapOne_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float Contrast {
                label {Contrast}
                description {
                    Scale the contrast by this amount.
                    Works by adjusting the mix between the texture value and the average texture value.
                    When Contrast = 0, the average value is produced.
                    When Contrast = 1, the texture value is produced.
                }
                detail varying
                subtype slider
                range {0 2}
                default 1
            }
            parameter coshader Contrast_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float Hue {
                label {Hue}
                description {
                    Offset the hue by this amount.
                    The hue has a range of 6, divided into 6 primaries (red, yellow, green, cyan, blue, magenta).
                    Each primary is one unit apart.
                    Hue is cyclical, so offsetting by a multiple of 6 produces no change.
                    To invert the hue, offset it by +/- 3.
                    NOTE: This is different than the ColorCorrect template's Hue control,
                    which has a range of 1.
                }
                detail varying
                subtype slider
                range {-3 3}
                default 0
            }
            parameter coshader Hue_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float Saturation {
                label Saturation
                description {
                    Scale the saturation by this amount.
                }
                detail varying
                subtype slider
                range {0 2}
                default 1
            }
            parameter coshader Saturation_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float Luminance {
                label {Luminance}
                description {
                    Scale the luminance by this amount.
                }
                detail varying
                subtype slider
                range {0 2}
                default 1
            }
            parameter coshader Luminance_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float Clamp {
                label {Clamp}
                description {
                    Selects if and how the data will be limited to the 0 to 1 range.
                }
                subtype selector
                range {
                    "Off"       0
                    "Clamp"     1
                    "Declip"    2
                    "Linear Step 7.5%"  3
                    "Linear Step 15%"   4
                    "Smoothstep"        5
                    "Rational Step"     6
                }
                default 0
            }
            parameter coshader Clamp_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter color Tint {
                label {Tint}
                description {
                    Multiply the result by this color.
                }
                detail varying
                default {1 1 1}
            }
            parameter coshader Tint_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float OutputConversion {
                label {Output Conversion}
                description {
                    Selects what conversion to perform on the adjusted result.
                }
                subtype selector
                range {
                    "None" 0
                    "Linear -> sRGB" 1
                    "sRGB -> Linear" 2
                }
                default 0
            }
            parameter coshader OutputConversion_Co_ {
                display hidden
                default {}
                value {}
            }
        }

        collection void Missing {
            label {Missing}
            description {
                Controls what to do when the texture file is not found.
            }

            parameter float IgnoreMissing {
                label {Ignore Missing}
                description {
                    When on, no warning for a missing texture will be issued,
                    and the Value, Average, and Alpha values will be used in its place.
                }
                subtype switch
                default 1
            }
            parameter coshader IgnoreMissing_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter color MissingValue {
                label {Value}
                description {
                    Output this Value if the texture file is missing.
                }
                detail varying
                default {0 0 0}
            }
            parameter coshader MissingValue_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter color MissingAverage {
                label {Average}
                description {
                    Output this Average if the texture file is missing.
                }
                detail varying
                default {0 0 0}
            }
            parameter coshader MissingAverage_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float MissingAlpha {
                label {Alpha}
                description {
                    Output this Alpha if the texture file is missing.
                }
                detail varying
                subtype slider
                range {0 1}
                default 0
            }
            parameter coshader MissingAlpha_Co_ {
                display hidden
                default {}
                value {}
            }
        }

        parameter color outValue {
            display hidden
            label {Value}
            access output
        }

        parameter color outAverage {
            display hidden
            label {Average}
            access output
        }

        parameter float outAlpha {
            display hidden
            label {Alpha}
            access output
        }


        RSLInclude {color.h}
        RSLInclude {pattern/texture.h}
        RSLInclude {coreV7/override.h}

        RSLSource DynamicFunction {
            proc primvars {} {}
            proc function {} {
                generateBody {

                    set overrideParam "Enable"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "File"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "FileType"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Channel"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Filter"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Blur"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Lerp"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "InputConversion"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Invert"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "ZeroValue"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying color   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "OneValue"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying color   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "RemapZero"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying color   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "RemapOne"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying color   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Contrast"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Hue"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Saturation"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Luminance"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Clamp"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Tint"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying color   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "OutputConversion"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "IgnoreMissing"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "MissingValue"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying color   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "MissingAverage"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying color   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "MissingAlpha"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

output "
                    outValue = color 0;
                    outAverage = color 0;
                    outAlpha = 0;

                    if (gridalways( abs(_Enable) == 0 )) return;

                    if (_IgnoreMissing)
                    {
                        outValue = _MissingValue;
                        outAverage = _MissingAverage;
                        outAlpha = _MissingAlpha;
                    }

                    if (_File == \"\") return;


                    varying float   x = xcomp( [getvar Q] );
                    varying float   y = ycomp( [getvar Q] );

                    if ([getvar FlipV]) y = 1.0 - y;


                    // Mari or Mudbox texture atlas.
                    if (_FileType != \"Single\")
                    {
                        textureatlasRead( _File, _FileType, _Channel, x, y,
                            [getvar UseFilterregion],
                            _IgnoreMissing,
                            _Filter,
                            _Blur,
                            outValue, outAverage, outAlpha
                        );
                    }


                    // Single texture file.
                    else
                    {
                        textureRead( _File, _Channel, x, 1-y,
                            [getvar UseFilterregion],
                            _IgnoreMissing,
                            _Filter,
                            _Blur,
                            _Lerp,
                            outValue, outAverage, outAlpha
                        );
                    }

                    if (_Channel == 5)
                    {
                        outValue = colorRGBToLuma( outValue );
                        outAverage = colorRGBToLuma( outAverage );
                    }
                    else if (_Channel == 6)
                    {
                        outValue = min( outValue\[0\], outValue\[1\], outValue\[2\] );
                        outAverage = min( outAverage\[0\], outAverage\[1\], outAverage\[2\] );
                    }
                    else if (_Channel == 7)
                    {
                        outValue = max( outValue\[0\], outValue\[1\], outValue\[2\] );
                        outAverage = max( outAverage\[0\], outAverage\[1\], outAverage\[2\] );
                    }

                    //
                    // Process the data.
                    //
                    if (_InputConversion == 1)
                    {
                        outValue = colorSRGBEncode( outValue );
                        outAverage = colorSRGBEncode( outAverage );
                    }

                    else if (_InputConversion == 2)
                    {
                        outValue = colorSRGBDecode( outValue );
                        outAverage = colorSRGBDecode( outAverage );
                    }

                    outValue = mix( outValue, color 1 - outValue, _Invert );
                    outAverage = mix( outAverage, color 1 - outAverage, _Invert );

                    outValue = linear( _ZeroValue, _OneValue, outValue );
                    outAverage = linear( _ZeroValue, _OneValue, outAverage );

                    outValue = mix( _RemapZero, _RemapOne, outValue );
                    outAverage = mix( _RemapZero, _RemapOne, outAverage );

                    outValue = mix( outAverage, outValue, _Contrast );

                    // Hue, Saturation, Luminance.
                    {
                        varying float   _Hue = _Hue / 6;
                        varying color   hsy, hsyavg;

                        hsy = ctransform (\"rgb\", \"HSY\", outValue);
                        hsyavg = ctransform (\"rgb\", \"HSY\", outAverage);

                        hsy += color (_Hue, 0, 0);
                        hsy *= color (1, _Saturation, _Luminance);
                        hsyavg += color (_Hue, 0, 0);
                        hsyavg *= color (1, _Saturation, _Luminance);

                        // Fix up hue to circumvent prman HSY space bug.
                        hsy = color( mod( hsy\[0\], 1 ), hsy\[1\], hsy\[2\] );
                        hsyavg = color( mod( hsyavg\[0\], 1 ), hsyavg\[1\], hsyavg\[2\] );

                        outValue = ctransform( \"HSY\", \"rgb\", hsy );
                        outAverage = ctransform( \"HSY\", \"rgb\", hsyavg );
                    }

                    // Clamping.
                    {
                        uniform float   _clamp = gridmax( _Clamp );

                        if (_clamp == 1)
                        {
                            outValue = clamp( outValue, color 0, color 1 );
                            outAverage = clamp( outAverage, color 0, color 1 );
                        }

                        else if (_clamp == 2)
                        {
                            outValue = colorDeclip( outValue );
                            outAverage = colorDeclip( outAverage );
                        }

                        else if (_clamp == 3)
                        {
                            outValue = linear( 0, 1, outValue );
                            outValue = color (
                                mathLinearSpline( .075, .075, outValue\[0\] ),
                                mathLinearSpline( .075, .075, outValue\[1\] ),
                                mathLinearSpline( .075, .075, outValue\[2\] )
                            );
                            outAverage = linear (0, 1, outAverage);
                            outAverage = color (
                                mathLinearSpline( .075, .075, outAverage\[0\] ),
                                mathLinearSpline( .075, .075, outAverage\[1\] ),
                                mathLinearSpline( .075, .075, outAverage\[2\] )
                            );
                        }

                        else if (_clamp == 4)
                        {
                            outValue = linear( 0, 1, outValue );
                            outValue = color (
                                mathLinearSpline( .15, .15, outValue\[0\] ),
                                mathLinearSpline( .15, .15, outValue\[1\] ),
                                mathLinearSpline( .15, .15, outValue\[2\] )
                            );
                            outAverage = linear (0, 1, outAverage);
                            outAverage = color (
                                mathLinearSpline( .15, .15, outAverage\[0\] ),
                                mathLinearSpline( .15, .15, outAverage\[1\] ),
                                mathLinearSpline( .15, .15, outAverage\[2\] )
                            );
                        }

                        else if (_clamp == 5)
                        {
                            outValue = _smoothstep( 0, 1, outValue );
                            outAverage = _smoothstep( 0, 1, outAverage );
                        }

                        else if (_clamp == 6)
                        {
                            outValue = linear( 0, 1, outValue );
                            outValue = color (
                                mathRationalSpline( .5, outValue\[0\] ),
                                mathRationalSpline( .5, outValue\[1\] ),
                                mathRationalSpline( .5, outValue\[2\] )
                            );
                            outAverage = linear( 0, 1, outAverage );
                            outAverage = color (
                                mathRationalSpline( .5, outAverage\[0\] ),
                                mathRationalSpline( .5, outAverage\[1\] ),
                                mathRationalSpline( .5, outAverage\[2\] )
                            );
                        }
                    }

                    outValue *= _Tint;
                    outAverage *= _Tint;

                    if (_OutputConversion == 1)
                    {
                        outValue = colorSRGBEncode( outValue );
                        outAverage = colorSRGBEncode( outAverage );
                    }

                    else if (_OutputConversion == 2)
                    {
                        outValue = colorSRGBDecode( outValue );
                        outAverage = colorSRGBDecode( outAverage );
                    }

                    outValue   *= _Enable;
                    outAverage *= _Enable;
                    outAlpha   *= _Enable;
"
                }
            }
        }
    }


    templateV multiple vectorTexture 1 {
        description {
            Access a single texture file or set of files generated by Mari or Mudbox.
        }

        parameter float Enable {
            label {Enable}
            description {
                Enable texture access or not.
            }
            detail varying
            subtype switch
            default 1
        }
        parameter coshader Enable_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string File {
            label File
            description {
                Specifies a Single file, or the set of files produced by Mari or Mudbox.
                When specifying a set of Mari or Mudbox files, choose any file name in the atlas
                (the collection of texture files obeying the file naming and texture mapping
                conventions they produce), then replace the map id portion of the file name with "_MAPID_".
                _MAPID_ will be substituted internally with the correct value to access the correct
                texture file based on their texture mapping convention.
            }
            provider variable
            detail varying
            subtype texture
            default ""
        }
        parameter coshader File_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string FileType {
            label {File Type}
            description {
                Selects the type of file access to use.
                "Single" accesses the texture File, and maps it onto the 0-1 range of the Manifold
                parameter's x and y coordinates.
                "Mari" uses the texture atlasing scheme produced by Mari.
                "Mudbox" uses the texture atlasing scheme produced by Mudbox.
            }
            subtype selector
            range {
                "Single" Single
                "Mari"   mari
                "Mudbox" mudbox
            }
            default mari
        }
        parameter coshader FileType_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string Filter {
            label Filter
            description {
                box is fast, but has artifacts.
                lagrangian is designed for speed and detail preservation.
                radial-bspline is designed for filtering bump/displacement textures.
                gaussian produces inherently smooth results but is expensive.
                disk is optimized for large blur sizes, is free of mipmap artifacts, but is very expensive.
                eliptical weighted average does anisotropic filtering, based on the
                surface orientation relative to the camera, so is the most "correct" result.
            }
            subtype selector
            range {
                "box" box
                "lagrangian" lagrangian
                "radial-bspline" radial-bspline
                "gaussian" gaussian
                "disk"     disk
                "eliptical weighted average" ewa
            }
            default box
        }
        parameter coshader Filter_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter float Blur {
            label Blur
            description {
                The size of the filter to use when accessing the texture data.
                Specified in 0 to 1 texture space (1 = the entire texture).
            }
            detail varying
            subtype slider
            range {0 .1 .001}
            default 0
        }
        parameter coshader Blur_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter float Lerp {
            label Lerp
            description {
                Selects whether to interpolate between adjacent resolutions
                of a multi-resolution texture in order to smooth the
                transition between resolutions.
            }
            subtype switch
            default 0
        }
        parameter coshader Lerp_Co_ {
            display hidden
            default {}
            value {}
        }

        collection manifold Manifold {
            label {Manifold}
            description {
                The space the texture will be mapped to.
            }
            parameter point Q { detail mustvary }
            parameter vector dQu { detail mustvary }
            parameter vector dQv { detail mustvary }
            detail mustvary "laika,UV" inline
        }

        parameter float FlipV {
            label {Flip V}
            description {
                Flip the V orientation of the texture.
            }
            subtype switch
            default 0
        }

        parameter float UseFilterregion {
            label {Use Filterregion}
            description {
                Use filterregion texture access.
            }
            subtype switch
            default 0
        }

        parameter float RangeConversion {
            label {Range Conversion}
            description {
                Selects how to convert the data read from the texture file before it's output.
                For example, Mari stores vector paint as 0,1 range data, so you might want to
                convert that to -1,1 before it's used.
            }
            subtype selector
            range {
                "None" 0
                "0,1 -> -1,1" 1
            }
            default 0
        }

        parameter float Scale {
            label {Scale}
            description {
                Multiply the result by this value.
            }
            detail varying
            default 1
        }
        parameter coshader Scale_Co_ {
            display hidden
            default {}
            value {}
        }

        collection void Missing {
            label {Missing}
            description {
                Controls what to do when the texture file is not found.
            }

            parameter float IgnoreMissing {
                label {Ignore Missing}
                description {
                    When on, no warning for a missing texture will be issued,
                    and the Value, Average, and Alpha values will be used in its place.
                }
                subtype switch
                default 1
            }
            parameter coshader IgnoreMissing_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter vector MissingValue {
                label {Value}
                description {
                    Output this Value if the texture file is missing.
                }
                detail varying
                default {0 0 0}
            }
            parameter coshader MissingValue_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter vector MissingAverage {
                label {Average}
                description {
                    Output this Average if the texture file is missing.
                }
                detail varying
                default {0 0 0}
            }
            parameter coshader MissingAverage_Co_ {
                display hidden
                default {}
                value {}
            }

            parameter float MissingAlpha {
                label {Alpha}
                description {
                    Output this Alpha if the texture file is missing.
                }
                detail varying
                subtype slider
                range {0 1}
                default 0
            }
            parameter coshader MissingAlpha_Co_ {
                display hidden
                default {}
                value {}
            }
        }

        parameter vector outValue {
            display hidden
            label {Value}
            access output
        }

        parameter vector outAverage {
            display hidden
            label {Average}
            access output
        }

        parameter float outAlpha {
            display hidden
            label {Alpha}
            access output
        }


        RSLInclude {sl.h}
        RSLInclude {pattern/texture.h}
        RSLInclude {coreV7/override.h}

        RSLSource DynamicFunction {
            proc primvars {} {}
            proc function {} {
                generateBody {

                    set overrideParam "Enable"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "File"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "FileType"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Filter"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Blur"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Lerp"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Scale"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "IgnoreMissing"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "MissingValue"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying vector  _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "MissingAverage"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying vector  _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "MissingAlpha"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

output "
                    outValue = vector 0;
                    outAverage = vector 0;
                    outAlpha = 0;

                    if (gridalways( abs(_Enable) == 0 )) return;

                    varying color   texValue = color 0;
                    varying color   texAverage = color 0;

                    if (_IgnoreMissing)
                    {
                        texValue = color _MissingValue;
                        texAverage = color _MissingAverage;
                        outAlpha = _MissingAlpha;

                        texValue = color _MissingValue;
                        texAverage = color _MissingAverage;
                    }

                    if (_File == \"\") return;


                    varying float   x = xcomp( [getvar Q] );
                    varying float   y = ycomp( [getvar Q] );

                    if ([getvar FlipV]) y = 1.0 - y;


                    // Mari or Mudbox texture atlas.
                    if (_FileType != \"Single\")
                    {
                        textureatlasRead( _File, _FileType, 4, x, y,
                            [getvar UseFilterregion],
                            _IgnoreMissing,
                            _Filter,
                            _Blur,
                            texValue, texAverage, outAlpha
                        );
                    }

                    // Single texture file.
                    else
                    {
                        textureRead( _File, 4, x, 1-y,
                            [getvar UseFilterregion],
                            _IgnoreMissing,
                            _Filter,
                            _Blur,
                            _Lerp,
                            texValue, texAverage, outAlpha
                        );
                    }

                    outValue = vector texValue;
                    outAverage = vector texAverage;

                    if ([getvar RangeConversion])
                    {
                        outValue = _mix( -1.0, 1.0, outValue );
                        outAverage = _mix( -1.0, 1.0, outAverage );
                    }

                    outValue   *= _Enable * _Scale;
                    outAverage *= _Enable * _Scale;
                    outAlpha   *= _Enable * _Scale;
"
                }
            }
        }
    }


    templateV vector normalmapTexture 1 {
        description {
            Reads a Normal Map texture, and produces the proper data for a BumpDisp Vector connection.
        }

        parameter float Enable {
            label {Enable}
            description {
                Enable texture access or not.
            }
            detail varying
            subtype switch
            default 1
        }
        parameter coshader Enable_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string File {
            label File
            description {
                Specifies a Single file, or the set of files produced by Mari or Mudbox.
                When specifying a set of Mari or Mudbox files, choose any file name in the atlas
                (the collection of texture files obeying the file naming and texture mapping
                conventions they produce), then replace the map id portion of the file name with "_MAPID_".
                _MAPID_ will be substituted internally with the correct value to access the correct
                texture file based on their texture mapping convention.
            }
            provider variable
            detail varying
            subtype texture
            default ""
        }
        parameter coshader File_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string FileType {
            label {File Type}
            description {
                Selects the type of file access to use.
                "Single" accesses the texture File, and maps it onto the 0-1 range of the Manifold
                parameter's x and y coordinates.
                "Mari" uses the texture atlasing scheme produced by Mari.
                "Mudbox" uses the texture atlasing scheme produced by Mudbox.
            }
            subtype selector
            range {
                "Single" Single
                "Mari"   mari
                "Mudbox" mudbox
            }
            default mari
        }
        parameter coshader FileType_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter string Filter {
            label Filter
            description {
                box is fast, but has artifacts.
                lagrangian is designed for speed and detail preservation.
                radial-bspline is designed for filtering bump/displacement textures.
                gaussian produces inherently smooth results but is expensive.
                disk is optimized for large blur sizes, is free of mipmap artifacts, but is very expensive.
                eliptical weighted average does anisotropic filtering, based on the
                surface orientation relative to the camera, so is the most "correct" result.
            }
            subtype selector
            range {
                "box" box
                "lagrangian" lagrangian
                "radial-bspline" radial-bspline
                "gaussian" gaussian
                "disk"     disk
                "eliptical weighted average" ewa
            }
            default box
        }
        parameter coshader Filter_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter float Blur {
            label Blur
            description {
                The size of the filter to use when accessing the texture data.
                Specified in 0 to 1 texture space (1 = the entire texture).
            }
            detail varying
            subtype slider
            range {0 .1 .001}
            default 0
        }
        parameter coshader Blur_Co_ {
            display hidden
            default {}
            value {}
        }

        parameter float Lerp {
            label Lerp
            description {
                Selects whether to interpolate between adjacent resolutions
                of a multi-resolution texture in order to smooth the
                transition between resolutions.
            }
            subtype switch
            default 0
        }
        parameter coshader Lerp_Co_ {
            display hidden
            default {}
            value {}
        }

        collection manifold Manifold {
            label {Manifold}
            description {
                The space the texture will be mapped to.
            }
            parameter point Q { detail mustvary }
            parameter vector dQu { detail mustvary }
            parameter vector dQv { detail mustvary }
            detail mustvary "laika,UV" inline
        }

        parameter float FlipV {
            label {Flip V}
            description {
                Flip the V orientation of the texture.
            }
            subtype switch
            default 0
        }

        parameter float UseFilterregion {
            label {Use Filterregion}
            description {
                Use filterregion texture access.
            }
            subtype switch
            default 0
        }

        parameter float RangeConversion {
            label {Range Conversion}
            description {
                Selects how to convert the data read from the texture file before it's output.
                For example, Mari stores vector paint as 0,1 range data, so you might want to
                convert that to -1,1 before it's used.
            }
            subtype selector
            range {
                "None" 0
                "0,1 -> -1,1" 1
            }
            default 1
        }

        collection void Temp {
            display hidden
            label {XXX development controls}
            description {
                Find the right settings for these, and then we'll hard-code that behavior into the template.
            }

            parameter float Normalize {
                detail uniform
                subtype switch
                default 1
            }

            parameter float FlipT {
                detail uniform
                subtype switch
                default 0
            }

            parameter float FlipB {
                detail uniform
                subtype switch
                default 0
            }

            parameter float FlipN {
                detail uniform
                subtype switch
                default 0
            }
        }

        parameter vector result {
            display hidden
            access output
        }

        RSLInclude {sl.h}
        RSLInclude {pattern/texture.h}
        RSLInclude {coreV7/override.h}

        RSLSource DynamicFunction {
            proc primvars {} {}
            proc function {} {
                generateBody {

                    set overrideParam "Enable"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "File"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "FileType"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Filter"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform string  _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Blur"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "varying float   _$overrideParam = overrideV( $coParam, [getvar $overrideParam] );"

                    set overrideParam "Lerp"
                    set coParam [safeeval [safeeval %c GetProperties -name "${overrideParam}_Co_"] GetNameSL 1]
                    output "uniform float   _$overrideParam = overrideU( $coParam, [getvar $overrideParam] );"

output "
                    extern float    s, t;
                    extern vector   dPdu, dPdv;
                    extern normal   N;

                    if (_File == \"\")
                    {
                        result = vector 0;
                        return;
                    }

"
                    # // XXX temp code to determine the proper computation.
                    # if ([getvar Normalize]) {
                    #     T = normalize(T);
                    #     B = normalize(B);
                    #     Nn = normalize(Nn);
                    # }
                    # if ([getvar FlipT]) T = -T;
                    # if ([getvar FlipB]) B = -B;
                    # if ([getvar FlipN]) Nn = -Nn;
output "
                    varying color   texValue = color 0.5;
                    varying color   texAverage = color 0.5;
                    varying float   outAlpha = 0;

                    varying float   x = xcomp( [getvar Q] );
                    varying float   y = ycomp( [getvar Q] );

                    if ([getvar FlipV]) y = 1.0 - y;


                    // Mari or Mudbox texture atlas.
                    if (_FileType != \"Single\")
                    {
                        textureatlasRead( _File, _FileType, 4, x, y,
                            [getvar UseFilterregion],
                            1,
                            _Filter,
                            _Blur,
                            texValue, texAverage, outAlpha
                        );
                    }

                    // Single texture file.
                    else
                    {
                        textureRead( _File, 4, x, 1-y,
                            [getvar UseFilterregion],
                            1,
                            _Filter,
                            _Blur,
                            _Lerp,
                            texValue, texAverage, outAlpha
                        );
                    }

                    if ([getvar RangeConversion])
                    {
                        texValue = _mix( -1.0, 1.0, texValue );
                    }


                    // Set up normal map eigenvectors (current space, st oriented).
                    varying float   dus = Du(s),
                                    dut = Du(t),
                                    dvs = Dv(s),
                                    dvt = Dv(t);

                    varying float   det = (dus*dvt - dut*dvs);
                    varying vector  T = ((dPdu*dvt - dPdv*dut) / det);
                    varying vector  B = ((dPdv*dus - dPdu*dvs) / det);
                    varying vector  Nn = vector (N);

                    T = normalize(T);
                    B = normalize(B);
                    Nn = normalize(Nn);


                    // Sum the scaled eigenvectors to produce a current space surface normal vector.
                    result = texValue\[0\]*T + texValue\[1\]*B + texValue\[2\]*Nn;
                    result = normalize( result );
"
                }
            }
        }
    }

  }
}
