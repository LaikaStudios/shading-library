##
##  Copyright(c) 2010-2014 Laika, developed under contract by mitchpraterLLC.
##  All rights reserved unless otherwise granted. This program or documentation
##  contains proprietary, confidential information and trade secrets of Laika
##  and/or mitchpraterLLC. Use of copyright notice does not imply publication.
##  
##  By possessing this software, you agree to the following terms and conditions.
##  You may not resell this software, but you may freely distribute it to others.
##  You may use it for whatever purposes you wish. There are no warranties of any
##  kind. You may make modifications, however any derivation may only be distributed
##  to others under the same freedoms granted to you herein, it must retain this
##  notice and agreement, and the modifications noted. We also ask that you make
##  such modifications available to Laika, mitchpraterLLC, or to the computer
##  graphics community as a whole through a public forum.
##
slim 1 extensions mprater {
  extensions laika vfx {

    templateV multiple Worley 1 {
        description {
            Produces various Worley/Voronoi patterns.
            These are all based on the distances between random points.
        }

        collection manifold Manifold {
            label {Manifold}
            description {
                Defines the space in which the pattern will be generated.
            }
            parameter point Q {detail mustvary}
            parameter vector dQu {detail mustvary}
            parameter vector dQv {detail mustvary}

            detail mustvary "laika,Pshader"
        }

        parameter float Frequency {
            label {Frequency}
            description {
                Sets the scale of the resulting pattern.
            }
            detail uniform
            subtype slider
            range {.1 10}
            default 5
        }

        slimattribute string Type {
            label {Distance Measure}
            description {
                Selects how to measure the distance between points.
            }
            subtype selector
            range {
                Euclidean Euclidean
                Minkovsky Minkovsky
                Manhattan Manhattan
                Chebyshev Chebyshev
            }
            default Euclidean

            msghandler {
                SetValue {
                    set typeParam %obj
                    set typeValue [$typeParam GetValue]
                    set app [$typeParam GetAppearance]

                    switch $typeValue {
                        Minkovsky {
                            [$app GetProperties -name Exponent] SetDisplayLevel ""
                        }
                        default {
                            [$app GetProperties -name Exponent] SetDisplayLevel "hidden"
                        }
                    }

                    $app UpdateEditor
                }
            }
        }

        parameter float Exponent {
            display hidden
            label {Minkovsky Exponent}
            description {
                The Minkovsky distance measure Exponent.
            }
            detail varying
            subtype slider
            range {1 8}
            default 4
        }

        parameter float Jitter {
            label {Jitter}
            description {
                Determines how much to randomize the points.
            }
            detail varying
            subtype slider
            range {0 1}
            default 1
        }

        parameter float Variation {
            label {Variation}
            description {
                Varies the resulting pattern.
                Useful for animating the effect.
            }
            detail varying
            subtype slider
            range {0 1}
            default 0
        }

        collection void Modifiers {
            state open
            label {Transition Modifiers}
            description {
                These modify the transition characteristics of the various output
                patterns they relate to.
            }

            parameter float F1Step {
                label {F Step}
                description {
                    Transitions the F1 distance measure over this range.
                    Effects all F outputs.
                }
                detail varying
                subtype slider
                range {0 .5}
                default 0
            }

            parameter float LineWidth {
                label {Line Width}
                description {
                    Controls the width of the Lines.
                }
                detail varying
                subtype slider
                range {.01 .5}
                default .05
            }

            parameter float LineBlur {
                label {Line Blur}
                description {
                    Controls the blurriness of the edges of the Lines.
                }
                detail varying
                subtype slider
                range {0 .5}
                default 0
            }

            parameter float VoronoiBlur {
                label {Voronoi Blur}
                description {
                    Determines the blurriness of the transition between the
                    cells in the Voronoi output.
                }
                detail varying
                subtype slider
                range {0 .5}
                default 0
            }

            parameter float CellWidth {
                label {Cell Width}
                description {
                    Determines the width of the transition region
                    between cells in the Cell outputs.
                }
                detail varying
                subtype slider
                range {0 .5}
                default 0
            }
        }

        parameter float Invert {
            label {Invert}
            description {
                Invert the Worley (float) output values.
            }
            detail uniform
            subtype switch
            default 0
        }

        slimattribute float Periodic {
            label {Periodic}
            description {
                Does the pattern repeat or not?
            }
            subtype switch
            default 0

            msghandler {
                SetValue {
                    set Param %obj
                    set Value [$Param GetValue]
                    set app [$Param GetAppearance]

                    switch $Value {
                        1 {
                            [$app GetProperties -name Period] SetDisplayLevel ""
                            [$app GetProperties -name VariationPeriod] SetDisplayLevel ""
                        }
                        default {
                            [$app GetProperties -name Period] SetDisplayLevel "hidden"
                            [$app GetProperties -name VariationPeriod] SetDisplayLevel "hidden"
                        }
                    }

                    $app UpdateEditor
                }
            }
        }
        parameter float Period {
            display hidden
            label {Manifold Period}
            description {
                At what Manifold dimension should the pattern repeat?
                Defines a cube in the Manifold space, where all cubes
                of this dimension contain the same pattern, and
                the pattern tiles from one cube to the next.
                Must be an integer.
            }
            detail uniform
            subtype slider
            range {1 20 1}
            default 5
        }
        parameter float VariationPeriod {
            display hidden
            label {Variation Period}
            description {
                Sets the repetition interval for the Variation.
                Must be an integer.
            }
            detail uniform
            subtype slider
            range {1 20 1}
            default 5
        }

        parameter float F1 {
            display hidden
            access output
        }
        parameter float F2 {
            display hidden
            access output
        }
        parameter float F2minusF1 {
            label {F2 - F1}
            display hidden
            access output
        }
        parameter float Line {
            label {Lines}
            display hidden
            access output
        }
        parameter color Voronoi {
            display hidden
            access output
        }
        collection manifold CellMap {
            label {Cell Map}
            display hidden
            access output
            parameter point QCellMap {access output}
            parameter vector dQuCellMap {access output}
            parameter vector dQvCellMap {access output}
        }
        collection manifold CellPoint {
            label {Cell Point}
            display hidden
            access output
            parameter point QCellPoint {access output}
            parameter vector dQuCellPoint {access output}
            parameter vector dQvCellPoint {access output}
        }


        RSLInclude {sl.h}
        RSLInclude {filter.h}

        RSLSource DynamicFunction {
            proc primvars {} {} 
            proc function {} {
                generateBody {
output "
                    varying point   Qfreq, Qfloor;

                    Qfreq = Q * [getvar Frequency];
                    Qfloor = _floor(Qfreq);

                    //
                    // Generate dQ and others.
                    //
                    varying float   dQ;
                    varying float   dVoronoi;
                    {
                        filterregion    Qfilt;

                        Qfilt->calculate3d(Qfreq);
                        dQ = sqrt(Qfilt->minsize() * Qfilt->maxsize());

                        dVoronoi = max (dQ, [getvar VoronoiBlur]);

                        dQuCellPoint = dQuCellMap = dQu;
                        dQvCellPoint = dQvCellMap = dQv;
                    }

                    //
                    // Set up variational values.
                    //
                    varying float   Vceil, Vfloor, variation;
"
                    if {[getval Periodic]} {
                        output "
                            Vceil = mod (ceil ([getvar Variation]), [getvar VariationPeriod]);
                            Vfloor = mod (floor ([getvar Variation]), [getvar VariationPeriod]);
                            variation = mod ([getvar Variation], [getvar VariationPeriod]) - Vfloor;
                        "
                    } else {
                        output "
                            Vceil = ceil ([getvar Variation]);
                            Vfloor = floor ([getvar Variation]);
                            variation = [getvar Variation] - Vfloor;
                        "
                    }
output "
                    //
                    // Divide space into cells and randomly place a point within each.
                    // Then measure the distances between points:
                    // F1 is the distance between nearest points.
                    // F2 is the distance to the second nearest point.
                    //
                    uniform float   i, j, k;
                    varying point   cellq, cellp, celln, q;
                    varying float   dist, F1step, F2step;

                    varying point   cellpoint, cellmap;

                    Voronoi = color .5;
                    QCellPoint = point 0;
                    QCellMap = point 0;
                    F1 = F2 = 10;   // Anything more than 3 is fine.
                    for (i=-1; i<=1; i+=1) {
                        for (j=-1; j<=1; j+=1) {
                            for (k=-1; k<=1; k+=1) {
                                cellq = Qfloor + vector(i,j,k);
"
                                if {[getval Periodic]} {
                                    output "cellp = _mod (cellq, round([getvar Frequency]*[getval Period]));"
                                } else {
                                    output "cellp = cellq;"
                                }
output "
                                celln = mix (
                                    point cellnoise (cellp, Vfloor),
                                    point cellnoise (cellp, Vceil),
                                    variation
                                );

                                q = cellq + vector([getvar Jitter]*celln);

                                cellpoint = q / [getvar Frequency];
                                cellmap = q - vector Qfreq;
"
                                # Generate the selected distance measurement.
                                switch [getval Type] {
                                    Euclidean   { output "
                                                    // Euclidean
                                                    q -= vector Qfreq;
                                                    dist = length(vector q);
                                                " }
                                    Minkovsky   { output "
                                                    // Minkovsky
                                                    q -= vector Qfreq;
                                                    q = _abs (q);
                                                    q = _pow (q, [getvar Exponent]);
                                                    dist = pow (xcomp(q) + ycomp(q) + zcomp(q), 1/[getvar Exponent]);
                                                " }
                                    Manhattan   { output "
                                                    // Manhattan
                                                    q -= vector Qfreq;
                                                    q = _abs(q);
                                                    dist = xcomp(q) + ycomp(q) + zcomp(q);
                                                    dist /= 2;
                                                " }
                                    Chebyshev   { output "
                                                    // Chebyshev
                                                    q -= vector Qfreq;
                                                    q = _abs(q);
                                                    dist = max (xcomp(q), ycomp(q), zcomp(q));
                                                " }
                                }
output "
                                // Filtered Voronoi patterns.
                                Voronoi = mix (color celln, Voronoi, filterstep (F1, dist, dist+dVoronoi));

                                varying float   cellEdge;
                                cellEdge = filterstep (F1, dist, dist + [getvar CellWidth]);

                                QCellPoint = mix (cellpoint, QCellPoint, cellEdge);
                                QCellMap = mix (cellmap, QCellMap, cellEdge);

                                // Generate conditional step functions (in lieu of if statements).
                                // Using smoothstep() works better than filterstep().
                                F1step = smoothstep( dist-[getvar F1Step], dist+[getvar F1Step], F1);
                                F2step = mix (step (dist, F2), 0, F1step);

                                // If there's a new F1.
                                F2 = mix (F2, F1, F1step);
                                F1 = mix (F1, dist, F1step);

                                // If there's a new F2.
                                F2 = mix (F2, dist, F2step);
                            }
                        }
                    }

                    F2minusF1 = F2 - F1;

                    // Generate the Line output.
                    {
                        filterregion    Lfilt;
                        varying float   dL;

                        Lfilt->calculate1d(F2minusF1);
                        dL = sqrt(Lfilt->minsize() * Lfilt->maxsize());

                        dL = max (dL, [getvar LineBlur]);
                        Line = filterstep (LineWidth, F2minusF1, F2minusF1+dL);
                    }

                    if ([getvar Invert]) {
                        F1 = 1 - F1;
                        F2 = 1 - F2;
                        F2minusF1 = 1 - F2minusF1;
                        Line = 1 - Line;
                    }
"
                }
            }
        }
    }

  }
}
