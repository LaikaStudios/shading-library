##
##  Copyright(c) 2014-2015 Laika, developed under contract by mitchpraterLLC.
##  All rights reserved unless otherwise granted. This program or documentation
##  contains proprietary, confidential information and trade secrets of Laika
##  and/or mitchpraterLLC. Use of copyright notice does not imply publication.
##  
##  By possessing this software, you agree to the following terms and conditions.
##  You may not resell this software, but you may freely distribute it to others.
##  You may use it for whatever purposes you wish. There are no warranties of any
##  kind. You may make modifications, however any derivation may only be distributed
##  to others under the same freedoms granted to you herein, it must retain this
##  notice and agreement, and the modifications noted. We also ask that you make
##  such modifications available to Laika, mitchpraterLLC, or to the computer
##  graphics community as a whole through a public forum.
##
slim 1 extensions mprater {
  extensions laika vfx {

    templateV arealight GeoEnv 1 {
        lighttype envAreaLight
        description {
            A Geometric Environment light.
        }

        eval [::__categoryParam "stdrsl_plausible,ikaGeolight"]

        parameter string __group {
            label {__group}
            description {
                Designate what __group this light belongs to.
                The effect of all lights in a given group can be output as AOV's by the Material shader.
                While a light may belong to many categories, it can only be assigned a single __group.
            }
            provider parameterlist
            detail uniform
            default ""
        }

        parameter float Enable {
            label {Enable}
            description {
                Determines how much effect this will have.
            }
            detail varying
            subtype slider
            range {0 1}
            default 1
        }

        parameter float Intensity {
            label {Intensity}
            description {
                The sRGB intensity of the light.
            }
            detail varying
            subtype slider
            range {0 10}
            default 1
        }

        parameter float Exposure {
            label {Exposure}
            description {
                Exposure compensation. 0 produces no change in light intensity.
                Positive values increase the intensity, negative ones decrease it.
                +1 increases the intensity by one stop. -1 decreases it by one stop.
            }
            detail varying
            subtype slider
            range {-2 2}
            default 0
        }

        parameter color Color {
            label {Color}
            description {
                The color of the light. You can connect a pattern generator here
                or simply use a constant color.
                If a Map is provided, this will be used to tint it.
            }
            detail varying
            default {1 1 1}
        }

        parameter string ColorMode {
            label {Color Mode}
            description {
                Selects whether the Color parameter is an sRGB or light-linear value.
            }
            detail uniform
            subtype selector
            range {
                "sRGB"   sRGB
                "Linear" Linear
            }
            default Linear
        }

        parameter string EnvMap {
            label {Environment Map}
            description {
                A linear color space lat-lon Environment Map.
                This will only be used if the light is attached to an "envsphere" geometric primitive.
            }
            detail varying
            subtype environment
            default ""
        }

        parameter float EnvRadius {
            label {Environment Radius}
            description {
                Defines the radius of the Environment.
                -1 == infinity.
            }
            detail uniform
            subtype slider
            range {0 1000}
            default -1
        }

        parameter color DiffuseTint {
            label {Diffuse Tint}
            description {
                A multiplier applied to the diffuse illumination.
                sRGB space.
            }
            detail varying
            default {1 1 1}
        }
        parameter float DiffuseIntensity {
            label {Diffuse Intensity}
            description {
                A multiplier applied to the diffuse illumination.
                sRGB space.
            }
            detail varying
            subtype slider
            range {0 2}
            default 1
        }

        parameter color SpecularTint {
            label {Specular Tint}
            description {
                A multiplier applied to the specular illumination.
                sRGB space.
            }
            detail varying
            default {1 1 1}
        }
        parameter float SpecularIntensity {
            label {Specular Intensity}
            description {
                A multiplier applied to the specular illumination.
                sRGB space.
            }
            detail varying
            subtype slider
            range {0 2}
            default 1
        }

        parameter float Visibility {
            label {Visibility}
            description {
                Determines whether the light's surface is visible in the scene or not.
                Only works if the surface's camera visibility attribute is 1.
            }
            detail varying
            subtype switch
            default 0
        }

        collection void ShadowControls {
            label {Shadow Controls}
            description {
                These control the shadow computation.
            }

            parameter float ShadowEnable {
                label {Enable}
                description {
                    Determines how much effect shadows will have: the shadow density.
                }
                detail varying
                subtype slider
                range {0 1}
                default 1
            }

            parameter color ShadowColor {
                label {Color}
                description {
                    Sets the (linear) color of the shadow.
                }
                detail varying
                default {0 0 0}
            }

            parameter string ShadowMethod {
                label {Method}
                description {
                    Selects whether to use Ray Tracing, deep Area Shadow maps,
                    or Both to compute the shadows.
                }
                subtype selector
                range {
                    "Ray Traced"  RayTrace
                    "Area Shadow" AreaShadow
                    "Both" Both
                }
                default RayTrace

                msghandler {
                    SetValue - RevertValue {
                        set app [%obj GetAppearance]
                        set paramValue [%obj GetValue]

                        set displayList [$app GetProperties -name "dtexFile_*"]
                        foreach param $displayList {
                            $param SetDisplayLevel "hidden"
                        }
                        [$app GetProperties -name RayTraceControls] SetDisplayLevel "hidden"
                        [$app GetProperties -name ShadowMapControls] SetDisplayLevel "hidden"
                        [$app GetProperties -name ShdFiles] SetDisplayLevel "hidden"
                        [$app GetProperties -name MapBias] SetDisplayLevel "hidden"
                        [$app GetProperties -name LeakBias] SetDisplayLevel "hidden"
                        [$app GetProperties -name TraceBias] SetDisplayLevel "hidden"
                        [$app GetProperties -name Adaptive] SetDisplayLevel "hidden"
                        [$app GetProperties -name IncludeSet] SetDisplayLevel "hidden"
                        [$app GetProperties -name ExcludeSet] SetDisplayLevel "hidden"
                        [$app GetProperties -name HitMode] SetDisplayLevel "hidden"
                        [$app GetProperties -name HitSides] SetDisplayLevel "hidden"

                        if {$paramValue == "RayTrace" || $paramValue == "Both"} {
                            [$app GetProperties -name RayTraceControls] SetDisplayLevel ""
                            [$app GetProperties -name TraceBias] SetDisplayLevel ""
                            [$app GetProperties -name Adaptive] SetDisplayLevel ""
                            [$app GetProperties -name IncludeSet] SetDisplayLevel ""
                            [$app GetProperties -name ExcludeSet] SetDisplayLevel ""
                            [$app GetProperties -name HitMode] SetDisplayLevel ""
                            [$app GetProperties -name HitSides] SetDisplayLevel ""
                        }

                        if {$paramValue == "AreaShadow" || $paramValue == "Both"} {
                            [$app GetProperties -name ShadowMapControls] SetDisplayLevel ""

                            set displayList [$app GetProperties -name "dtexFile_*"]
                            foreach param $displayList {
                                $param SetDisplayLevel "removable"
                            }
                            [$app GetProperties -name ShdFiles] SetDisplayLevel ""
                            [$app GetProperties -name MapBias] SetDisplayLevel ""
                            [$app GetProperties -name LeakBias] SetDisplayLevel ""
                            [$app GetProperties -name Adaptive] SetDisplayLevel ""
                        }

                        $app UpdateEditor
                    }
                }
            }

            parameter float Adaptive {
                label {Adaptive}
                description {
                    Selects the level of adaptive sampling.
                    When enabled, fewer samples are used in regions of low shadow variance.
                }
                detail varying
                subtype selector
                range {
                    "Off" 0
                    "Conservative" 1
                    "Aggressive" 2
                }
                default 2
            }

            parameter float MaxDist {
                label {Max Dist}
                description {
                    How far away from the light to look for shadowing surfaces.
                    Used for traced shadows and AreaShadow Files.
                    Smaller values produce a more localized effect, and may decrease render times.
                    Larger distances will require more geometry to be tested,
                    and so may result in longer render times.
                    The value is dependent on your scene size and scale.
                    Reverting it to -1 is equivalent to making it infinite.
                }
                detail varying
                range {0 1e4}
                default -1
            }

            parameter string ShadowAOV {
                label {Shadow AOV}
                description {
                    If this is not blank, the shadow transmission value will be output
                    to a color AOV with this name.
                    Note that if two lights use the same AOV name, they will overwrite
                    each other's results.
                    Also note this will not work if Enable Gobos and Portals is on.
                }
                detail varying
                default ""
            }

            collection void RayTraceControls {
                label {Ray Trace Controls}

                parameter string IncludeSet {
                    label {Include Set}
                    description {
                        Specifies the set of objects that can cast shadows.
                        If blank, all objects in the scene are used.
                    }
                    detail varying
                    default ""
                }

                parameter string ExcludeSet {
                    label {Exclude Set}
                    description {
                        Specifies the set of objects to specifically ignore when casting shadows.
                        If blank, no objects will specifically be ignored.
                    }
                    detail varying
                    default ""
                }

                parameter float TraceBias {
                    label {Bias}
                    description {
                        Controls the surface offset to remove self-shadowing artifacts.
                        When set to -1, the RiAttribute "user:areashadowbias" value will be used.
                    }
                    detail uniform
                    subtype slider
                    range {0 .1 .001}
                    default -1
                }

                parameter string HitMode {
                    label {Hit Mode}
                    description {
                        Determines the opacity of the hit surface by examining the surface's
                        shade:transmissionhitmode attribute,
                        the primitive's Os vertex variable or Opacity attribute,
                        by running its shader to get the shaded opacity,
                        or by looking up the opacity cached in the point data file
                        specified by the shade:transmissionhitcache file attribute.
                    }
                    detail uniform
                    subtype selector
                    range {
                        transmissionhitmode default
                        primitive           primitive
                        shader              shader
                        cache               cache
                    }
                    default default
                }

                parameter string HitSides {
                    label {Hit Sides}
                    description {
                        Specifies which side(s) of surfaces can be hit by the shadow rays.
                    }
                    detail uniform
                    subtype selector
                    range {
                        "Front" "front"
                        "Back" "back"
                        "Front & Back" "both"
                    }
                    default "front"
                }
            }

            collection void ShadowMapControls {
                label {Shadow Map Controls}
                display hidden

                collection customuiFullWidth ShdFiles {
                    display hidden
                    customui laika AddParam
                    subtype propertycreator
                    drawmode children
                    state open
                    userdata {
                        AddString "Add AreaShadow File"
                        AddDescription "AreaShadow Deep Shadow Files added here will\nbe used to compute the shadow."
                        ParamType string
                        ParamSubtype file
                        ParamPrefix dtexFile
                        ParamLabel File
                        ParamDescription "The name of an AreaShadow deep shadow file. You can also use a tcl command such as [PassFileName rmanPassName] to refer to the file generated by a render pass."
                        ParamProvider variable
                        ParamDetail varying
                        ParamDefault {[PassFileName rmanAreaShadowPass]}
                    }
                }

                parameter float MapBias {
                    display hidden
                    label {Map Bias}
                    description {
                        Scales an automatically computed bias value when using AreaShadow Files.
                        In most cases the default value of 1 should be appropriate.
                    }
                    detail uniform
                    subtype slider
                    range {.5 2}
                    default 1
                }

                parameter float LeakBias {
                    display hidden
                    label {Leak Bias}
                    description {
                        Helps to control light leaks from AreaShadow Files.
                        With values above 0, each texel in the map will contribute
                        to the total shadowing using a slightly broader depth interval.
                        This can mitigate cases of aliasing on geometry seen obliquely
                        from the shadow generation camera. Typical values are 1 to 5.
                    }
                    detail uniform
                    subtype slider
                    range {0 5}
                    default 3.5
                }
            }
        }

        parameter float EnableGP {
            label {Enable Gobos and Portals}
            description {
                Enables the use of Gobo and Portal Geo Light Effectors.
                Region Geo Light Effectors are not influenced by this setting.
                Note that setting this will disable standard Light Effectors; and the
                shadows when Shadow Controls : Enable < 1, will not be clearly defined.
            }
            detail uniform
            subtype switch
            default 0
        }

        parameter float Samples {
            label {Samples}
            description {
                Sets the number of samples to use.
                When Default (-1), use the automatic sample balancing mechanism of prman.
            }
            detail uniform
            subtype slider
            range {-1 100 1}
            default -1
        }

        collection shader(0) __boundcoshaders {
            display hidden
            label {Bound Coshaders}
            description {
                Coshaders entered here will become known to the light so it can process them.
                These can be Geo Light Effectors or Light Effectors.
            }
            provider primitive

            parameter shader __boundcoshaders:0 {
                provider primitive
                default {}
                index 0
            }
        }

        collection customuiFullWidth AOVs {
            customui laika AddParam
            subtype propertycreator
            drawmode children
            state open
            userdata {
                AddString   "Add AOV"
                AddDescription "Allows you to add an Arbitrary Output Variable."
                ParamType   AOV
                ParamPrefix AOV
                ParamDetail {mustvary "laika,AOV" inline}
            }
        }

        RSLInclude {coreV7/light.h}
        RSLInclude {coreV7/radianceSample.h}

        RSLInclude {sl.h}
        RSLInclude {math.h}
        RSLInclude {color.h}

        RSLClass {
output "
            private light_s         _light;

            // Global variables.
            private varying color   lightCI;    // color*intensity

            private uniform shader  radianceEffectors\[\], shadowEffectors\[\];
            private uniform shader  ikaGeoLightGobo\[\], ikaGeoLightPortal\[\], ikaGeoLightRegion\[\];
            private uniform float   ikaGeoLightGoboNum, ikaGeoLightPortalNum, ikaGeoLightRegionNum;


            private constant string _dtexFiles\[\] = {};
            private constant float  _raytrace = 0;
            private varying float   _Visibility;
            private uniform float   _EnableGP;
            private varying float   _Enable;
            private varying color   _DiffuseTint;
            private varying float   _DiffuseIntensity;
            private uniform color   _diffusecontribution;
            private varying color   _SpecularTint;
            private varying float   _SpecularIntensity;
            private uniform color   _specularcontribution;
            private varying float   _Intensity;
            private varying float   _Exposure;
            private varying color   _Color;
            private varying float   _ShadowEnable;
            private varying color   _ShadowColor;
            private uniform float   _TraceBias;
            private uniform float   _MapBias;
            private uniform float   _LeakBias;
            private varying float   _MaxDist;
            private uniform float   _Adaptive;
            private uniform string  _IncludeSet;
            private uniform string  _ExcludeSet;
            private uniform string  _HitMode;
            private uniform string  _HitSides;
            private uniform string  _EnvMap;
            private uniform float   _Samples;
"

            generateMethod "public void construct()" {
                generate ShadowMethod
output "
                if ([getvar ShadowMethod] != \"AreaShadow\") {
                   _raytrace = 1;
                }

                if ([getvar ShadowMethod] != \"Raytrace\") {
"
                    set dtexFileList [getproperties -name dtexFile_* -access input]
                    foreach dtexFile $dtexFileList {
                        generate $dtexFile
output "
                        if ([getvar $dtexFile] != \"\") {
                            push( _dtexFiles, [getvar $dtexFile] );
                        }
" 
                    }
output "
                }
"
            }

            #  Intialize enable and handle any coshader overrides.
            generateMethod "public void begin()" {
                generate -dtexFile_* -ShaderEnable_*
output "
                _Enable = [getvar Enable];

                // Get the lighteffector coshaders.
                uniform string  categoryUser\[\] = split( __categoryUser, \",\" );

                getEffectorList( \"ikaRadianceEffector\", categoryUser, __boundcoshaders, radianceEffectors );
                getEffectorList( \"ikaShadowEffector\", categoryUser, __boundcoshaders, shadowEffectors );

                // Get the geolighteffector coshaders.
                getEffectorList( \"ikaGeoLightGobo\", categoryUser, __boundcoshaders, ikaGeoLightGobo );
                getEffectorList( \"ikaGeoLightPortal\", categoryUser, __boundcoshaders, ikaGeoLightPortal );
                getEffectorList( \"ikaGeoLightRegion\", categoryUser, __boundcoshaders, ikaGeoLightRegion );

                ikaGeoLightGoboNum = arraylength( ikaGeoLightGobo );
                ikaGeoLightPortalNum = arraylength( ikaGeoLightPortal );
                ikaGeoLightRegionNum = arraylength( ikaGeoLightRegion );

                // Initialize parameter variables.
                _Visibility = [getvar Visibility];
                _EnableGP = [getvar EnableGP];
                _DiffuseTint = [getvar DiffuseTint];
                _DiffuseIntensity = [getvar DiffuseIntensity];
                _SpecularTint = [getvar SpecularTint];
                _SpecularIntensity = [getvar SpecularIntensity];
                _Color = [getvar Color];
                _Intensity = [getvar Intensity];
                _Exposure = [getvar Exposure];
                _ShadowEnable = [getvar ShadowEnable];
                _ShadowColor = [getvar ShadowColor];
                _MapBias = [getvar MapBias];
                _LeakBias = [getvar LeakBias];
                _Adaptive = gridmin( [getvar Adaptive] );
                _IncludeSet = [getvar IncludeSet];
                _ExcludeSet = [getvar ExcludeSet];
                _HitMode = [getvar HitMode];
                _HitSides = [getvar HitSides];
                _EnvMap = [getvar EnvMap];
                _Samples = [getvar Samples];

                uniform float   tracebias = 0.01;
                attribute( \"trace:bias\", tracebias );
                if (attribute (\"user:areashadowbias\", _TraceBias) == 0) _TraceBias = tracebias;
                if ([getvar TraceBias] != -1) _TraceBias = [getvar TraceBias];

                // Determine the MaxDist.
                // -1 signifies infinity.
                _MaxDist = [getvar MaxDist];
                if (_MaxDist == -1) _MaxDist = MAXDIST;


                uniform float   EnvMapExists, dummy;
                EnvMapExists = textureinfo( _EnvMap, \"exists\", dummy );

                if (_EnvMap != \"\" && EnvMapExists == 0)
                {
                    printf( \"ERROR: %s EnvMap %s does not exist. \", __FILE__, _EnvMap );
                }


                _diffusecontribution = gridavg( colorSRGBToLinear( _DiffuseTint * _DiffuseIntensity ));
                _specularcontribution = gridavg( colorSRGBToLinear( _SpecularTint * _SpecularIntensity ));


                // Set the light colorintensity.
                extern varying color    lightCI;
                {
                    if ([getvar ColorMode] == \"sRGB\") _Color = colorSRGBToLinear( _Color );

                    varying float   lightIntensity = colorSRGBToLinear( _Intensity*_Enable ) * pow( 2,_Exposure );

                    lightCI = lightIntensity * _Color;
                }
"
            }

            generateMethod "public void prelighting( output color Ci, Oi )" {
output "
                uniform float   i, j;

                // Process gobos.
                uniform string  goboFile\[ikaGeoLightGoboNum\];
                uniform matrix  goboMatrix\[ikaGeoLightGoboNum\];

                j = 0;
                for (i=0; i < ikaGeoLightGoboNum; i+=1)
                {
                    ikaGeoLightGobo\[i\]->begin();
                    goboFile\[j\] = ikaGeoLightGobo\[i\]->File;
                    goboMatrix\[j\] = ikaGeoLightGobo\[i\]->Matrix;

                    if (goboFile\[j\] != \"\") j += 1;
                }
                resize( goboFile, j );
                resize( goboMatrix, j );
                ikaGeoLightGoboNum = j;

                // Process portals.
                uniform matrix  portalMatrix\[ikaGeoLightPortalNum\];

                for (i=0; i < ikaGeoLightPortalNum; i+=1)
                {
                    ikaGeoLightPortal\[i\]->begin();
                    portalMatrix\[i\] = ikaGeoLightPortal\[i\]->Matrix;
                }

                // XXX prman seg fault bug workaround.
                if (_EnableGP == 0) resize( portalMatrix,0 );

                // Process blockers.
                uniform matrix  blockerMatrix\[ikaGeoLightRegionNum\];
                uniform vector  blockerShape\[ikaGeoLightRegionNum\];
                uniform color   blockerTint\[ikaGeoLightRegionNum\],
                                blockerDiffuseTint\[ikaGeoLightRegionNum\],
                                blockerSpecularTint\[ikaGeoLightRegionNum\];

                for (i=0; i < ikaGeoLightRegionNum; i+=1)
                {
                    blockerMatrix\[i\] = ikaGeoLightRegion\[i\]->Matrix;
                    blockerShape\[i\] = ikaGeoLightRegion\[i\]->Shape;
                    blockerTint\[i\] = ikaGeoLightRegion\[i\]->Tint;
                    blockerDiffuseTint\[i\] = ikaGeoLightRegion\[i\]->DiffuseTint;
                    blockerSpecularTint\[i\] = ikaGeoLightRegion\[i\]->SpecularTint;
                }

                // Set shadow color.
                uniform color   shadowtint = gridavg( mix( _Color, _ShadowColor, _ShadowEnable ));

                // Geometry light emission.
#if __PRMAN_RELEASE__ >= 2000
                if (_Samples > -1)
                {
                    emit( lightCI,
/*                         \"direction\", N, */
                        \"environmentmap\", _EnvMap,
                        \"environmentradius\", [getvar EnvRadius],
                        \"filteredimportance\", 1,
                        \"diffusecontribution\", _diffusecontribution,
                        \"specularcontribution\", _specularcontribution,
                        \"blockers\", blockerMatrix,
                        \"blockershape\", blockerShape,
                        \"blockermultipliers\", blockerTint,
                        \"blockerdiffusemultipliers\", blockerDiffuseTint,
                        \"blockerspecularmultipliers\", blockerSpecularTint,
                        \"useshadowmethod\", 1-_EnableGP,
                        \"fixedsamplecount\", _Samples,

/*             These are unused when useshadowmethod is set. */
                        \"gobos\", goboMatrix,
                        \"gobomaps\", goboFile,
                        \"portals\", portalMatrix,
                        \"raytraceshadows\", _raytrace,
                        \"adaptiveshadow\", _Adaptive,
                        \"subset\", _IncludeSet,
                        \"excludesubset\", _ExcludeSet,
                        \"shadowbias\", _TraceBias,
                        \"shadowmaxdist\", _MaxDist,
                        \"shadowhitmode\", _HitMode,
                        \"shadowhitsides\", _HitSides,
                        \"shadowmaps\", _dtexFiles,
                        \"shadowmapbias\", _MapBias,
                        \"shadowmapbias2\", _LeakBias,
                        \"shadowtint\", shadowtint
                    );
                }
                else
#endif
                {
                    emit( lightCI,
/*                         \"direction\", N, */
                        \"environmentmap\", _EnvMap,
                        \"environmentradius\", [getvar EnvRadius],
                        \"filteredimportance\", 1,
                        \"diffusecontribution\", _diffusecontribution,
                        \"specularcontribution\", _specularcontribution,
                        \"blockers\", blockerMatrix,
                        \"blockershape\", blockerShape,
                        \"blockermultipliers\", blockerTint,
                        \"blockerdiffusemultipliers\", blockerDiffuseTint,
                        \"blockerspecularmultipliers\", blockerSpecularTint,
                        \"useshadowmethod\", 1-_EnableGP,

/*             These are unused when useshadowmethod is set. */
                        \"gobos\", goboMatrix,
                        \"gobomaps\", goboFile,
                        \"portals\", portalMatrix,
                        \"raytraceshadows\", _raytrace,
                        \"adaptiveshadow\", _Adaptive,
                        \"subset\", _IncludeSet,
                        \"excludesubset\", _ExcludeSet,
                        \"shadowbias\", _TraceBias,
                        \"shadowmaxdist\", _MaxDist,
                        \"shadowhitmode\", _HitMode,
                        \"shadowhitsides\", _HitSides,
                        \"shadowmaps\", _dtexFiles,
                        \"shadowmapbias\", _MapBias,
                        \"shadowmapbias2\", _LeakBias,
                        \"shadowtint\", shadowtint
                    );
                }
"
            }

            generateMethod "public void surface( output varying color Ci, Oi )" {
output "
                Ci = lightCI;
                Oi = color( _Visibility );

                Ci *= Oi;
"
            }

            generateMethod "public void shadowSamples( output __radiancesample samples\[\] )" {
output "
                filterregion    fr;
                fr->calculate3d( Ps );

                varying color   lightVisibility;
                varying color   lightTransmission;

                _light->begin();

                if (gridever(_ShadowEnable > 0))
                {
                    lightTransmission = color 1 - areashadow( _dtexFiles, fr, samples,
                        \"raytrace\", _raytrace,
                        \"adaptive\", _Adaptive,
                        \"subset\", _IncludeSet,
                        \"excludesubset\", _ExcludeSet,
                        \"bias\", _TraceBias,
                        \"maxdist\", _MaxDist,
                        \"hitmode\", _HitMode,
                        \"hitsides\", _HitSides,
                        \"mapbias\", _MapBias,
                        \"mapbias2\", _LeakBias
                    );
"
                    set shadowAOV [getproperties -name ShadowAOV]
output "
                    if ([getvar $shadowAOV] != \"\") writeaov( [getvar $shadowAOV], lightTransmission );

                    // Accumulate radiance effects onto the light color.
                    varying color   lightColor = accumulateRadianceEffects( radianceEffectors, _light );

                    uniform float   i, alen = arraylength( samples );
                    for (i=0; i < alen; i+=1)
                    {
                        lightVisibility = mix( color 1, samples\[i\]->lightVisibility, _ShadowEnable );
                        samples\[i\]->lightVisibility = mix( _ShadowColor, color 1, lightVisibility ) * lightColor;
                    }
                }
                else
                {
                    setLightVisibility( color 1, samples );
                }

                // Accumulate light shadow effects.
                applyShadowEffects( shadowEffectors, _light, samples );
"
            }
        }
    }

  }
}
