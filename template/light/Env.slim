##
##  Copyright(c) 2012-2014 Laika, developed under contract by mitchpraterLLC.
##  All rights reserved unless otherwise granted. This program or documentation
##  contains proprietary, confidential information and trade secrets of Laika
##  and/or mitchpraterLLC. Use of copyright notice does not imply publication.
##  
##  By possessing this software, you agree to the following terms and conditions.
##  You may not resell this software, but you may freely distribute it to others.
##  You may use it for whatever purposes you wish. There are no warranties of any
##  kind. You may make modifications, however any derivation may only be distributed
##  to others under the same freedoms granted to you herein, it must retain this
##  notice and agreement, and the modifications noted. We also ask that you make
##  such modifications available to Laika, mitchpraterLLC, or to the computer
##  graphics community as a whole through a public forum.
##
slim 1 extensions mprater {
  extensions laika vfx {

    templateV light ikaV7Env 0 {
        lighttype area
        description {
            A plausible Environment light.
        }

        eval [::__categoryParam "stdrsl_plausible,ikaV7Light"]

        parameter string __group {
            label {__group}
            description {
                Designate what __group this light belongs to.
                The effect of all lights in a given group can be output as AOV's by the Material shader.
                While a light may belong to many categories, it can only be assigned a single __group.
            }
            provider parameterlist
            detail uniform
            default ""
        }

        parameter float Enable {
            label {Enable}
            description {
                Determines how much effect this will have.
            }
            detail varying
            subtype slider
            range {0 1}
            default 1
        }

        parameter float Intensity {
            label {Intensity}
            description {
                The sRGB intensity of the light.
            }
            detail varying
            subtype slider
            range {0 10}
            default 1
        }

        parameter float Exposure {
            label {Exposure}
            description {
                Exposure compensation. 0 produces no change in light intensity.
                Positive values increase the intensity, negative ones decrease it.
                +1 increases the intensity by one stop. -1 decreases it by one stop.
            }
            detail varying
            subtype slider
            range {-2 2}
            default 0
        }

        parameter string EnvFile {
            label {Env Map}
            description {
                The Linear color space, Lat-Lon Environment Map to use.
                This will typically be from a light probe of a real scene.
                If blank, the Env Color will be used.
            }
            detail varying
            subtype environment
            default ""
        }

        parameter string EnvSpace {
            label {Map Space}
            description {
                Transform the Env Map to this space before accessing it.
                This defines the origin and orientation of the Env Map.
                If "shader", the coordinate system of the light this is attached to will be used.
            }
            detail varying
            default "shader"
        }

        parameter color Color {
            label {Color}
            description {
                When no Env Map is specified (blank), use this color for the environment.
                You can connect a pattern generator here or simply use a constant color.
                If the Env Map is specified, this will tint the result.
            }
            detail varying
            default {1 1 1}
        }

        parameter string ColorMode {
            label {Color Mode}
            description {
                Selects whether the Color parameter is an sRGB or light-linear value.
            }
            detail uniform
            subtype selector
            range {
                "sRGB"   sRGB
                "Linear" Linear
            }
            default Linear
        }

        parameter float DiffuseIntensity {
            label {Diffuse Intensity}
            description {
                A multiplier applied to the diffuse illumination.
                sRGB space.
            }
            detail varying
            subtype slider
            range {0 2}
            default 1
        }

        parameter color DiffuseTint {
            label {Diffuse Tint}
            description {
                A multiplier applied to the diffuse illumination.
                sRGB space.
            }
            detail varying
            default {1 1 1}
        }

        parameter float SpecularIntensity {
            label {Specular Intensity}
            description {
                A multiplier applied to the specular illumination.
                sRGB space.
            }
            detail varying
            subtype slider
            range {0 2}
            default 1
        }

        parameter color SpecularTint {
            label {Specular Tint}
            description {
                A multiplier applied to the specular illumination.
                sRGB space.
            }
            detail varying
            default {1 1 1}
        }

        parameter string Distribution {
            label {Distribution}
            description {
                Determines whether the distribution of samples is based on the luminance of
                the environment map (Importance), are weighted toward the center of the sampling cone (Cosine),
                or are Uniform.
            }
            detail uniform
            subtype selector
            range {
                "Importance" importance
                "Cosine"     cosine
                "Uniform"    uniform
            }
            default importance
        }

        parameter float Samples {
            label {Samples}
            description {
                Directly sets the number of light samples to use.
                When Default (-1), use the Attribute "user" "env_density" value.
            }
            detail uniform
            subtype slider
            range {-1 500 1}
            default -1
        }

        parameter float DepthReduction {
            label {Depth Reduction}
            description {
                Only effects depth > 0 rays.
                Reduce the number of light samples with ray depth.
                At each ray depth, the number of samples will be this
                percentage of the previous depth's number of samples.
                When 0, only 1 ray will be used for ray depths > 0.
            }
            detail uniform
            subtype slider
            range {0 .5}
            default .25
        }

        collection void ShadowControls {
            label {Shadow Controls}
            description {
                These control the shadow computation.
            }

            parameter float ShadowEnable {
                label {Enable}
                description {
                    Determines how much effect shadows will have: the shadow density.
                }
                detail varying
                subtype slider
                range {0 1}
                default 1
            }

            parameter color ShadowColor {
                label {Color}
                description {
                    Sets the (linear) color of the shadow.
                }
                detail varying
                default {0 0 0}
            }

            parameter string ShadowMethod {
                label {Method}
                description {
                    Selects whether to use Ray Tracing, deep Area Shadow maps,
                    or Both to compute the shadows.
                }
                subtype selector
                range {
                    "Ray Traced"  RayTrace
                    "Area Shadow" AreaShadow
                    "Both" Both
                }
                default RayTrace

                msghandler {
                    SetValue - RevertValue {
                        set app [%obj GetAppearance]
                        set paramValue [%obj GetValue]

                        set displayList [$app GetProperties -name "dtexFile_*"]
                        foreach param $displayList {
                            $param SetDisplayLevel "hidden"
                        }
                        [$app GetProperties -name RayTraceControls] SetDisplayLevel "hidden"
                        [$app GetProperties -name ShadowMapControls] SetDisplayLevel "hidden"
                        [$app GetProperties -name ShdFiles] SetDisplayLevel "hidden"
                        [$app GetProperties -name MapBias] SetDisplayLevel "hidden"
                        [$app GetProperties -name LeakBias] SetDisplayLevel "hidden"
                        [$app GetProperties -name TraceBias] SetDisplayLevel "hidden"
                        [$app GetProperties -name Adaptive] SetDisplayLevel "hidden"
                        [$app GetProperties -name IncludeSet] SetDisplayLevel "hidden"
                        [$app GetProperties -name ExcludeSet] SetDisplayLevel "hidden"
                        [$app GetProperties -name HitMode] SetDisplayLevel "hidden"
                        [$app GetProperties -name HitSides] SetDisplayLevel "hidden"

                        if {$paramValue == "RayTrace" || $paramValue == "Both"} {
                            [$app GetProperties -name RayTraceControls] SetDisplayLevel ""
                            [$app GetProperties -name TraceBias] SetDisplayLevel ""
                            [$app GetProperties -name Adaptive] SetDisplayLevel ""
                            [$app GetProperties -name IncludeSet] SetDisplayLevel ""
                            [$app GetProperties -name ExcludeSet] SetDisplayLevel ""
                            [$app GetProperties -name HitMode] SetDisplayLevel ""
                            [$app GetProperties -name HitSides] SetDisplayLevel ""
                        }

                        if {$paramValue == "AreaShadow" || $paramValue == "Both"} {
                            [$app GetProperties -name ShadowMapControls] SetDisplayLevel ""

                            set displayList [$app GetProperties -name "dtexFile_*"]
                            foreach param $displayList {
                                $param SetDisplayLevel "removable"
                            }
                            [$app GetProperties -name ShdFiles] SetDisplayLevel ""
                            [$app GetProperties -name MapBias] SetDisplayLevel ""
                            [$app GetProperties -name LeakBias] SetDisplayLevel ""
                            [$app GetProperties -name Adaptive] SetDisplayLevel ""
                        }

                        $app UpdateEditor
                    }
                }
            }

            parameter float Adaptive {
                label {Adaptive}
                description {
                    Selects the level of adaptive sampling.
                    When enabled, fewer samples are used in regions of low shadow variance.
                }
                detail varying
                subtype selector
                range {
                    "Off" 0
                    "Conservative" 1
                    "Aggressive" 2
                }
                default 2
            }

            parameter float MaxDist {
                label {Max Dist}
                description {
                    How far away from the light to look for shadowing surfaces.
                    Used for traced shadows and AreaShadow Files.
                    Smaller values produce a more localized effect, and may decrease render times.
                    Larger distances will require more geometry to be tested,
                    and so may result in longer render times.
                    The value is dependent on your scene size and scale.
                    Reverting it to -1 is equivalent to making it infinite.
                }
                detail varying
                range {0 1e4}
                default -1
            }

            parameter string ShadowAOV {
                label {Shadow AOV}
                description {
                    If this is not blank, the shadow transmission value will be output
                    to a color AOV with this name.
                    Note that if two lights use the same AOV name, they will overwrite
                    each other's results.
                }
                detail varying
                default ""
            }

            collection void RayTraceControls {
                label {Ray Trace Controls}

                parameter string IncludeSet {
                    label {Include Set}
                    description {
                        Specifies the set of objects that can cast shadows.
                        If blank, all objects in the scene are used.
                    }
                    detail varying
                    default ""
                }

                parameter string ExcludeSet {
                    label {Exclude Set}
                    description {
                        Specifies the set of objects to specifically ignore when casting shadows.
                        If blank, no objects will specifically be ignored.
                    }
                    detail varying
                    default ""
                }

                parameter float TraceBias {
                    label {Bias}
                    description {
                        Controls the surface offset to remove self-shadowing artifacts.
                        When set to -1, the RiAttribute "user" "areashadowbias" value will be used,
                        if it exists, or "trace" "bias" if it does not.
                        When using RPS 19, just leave "trace" "autobias" at 1 and forget about setting bias values.
                    }
                    detail uniform
                    subtype slider
                    range {0 .1 .001}
                    default -1
                }

                parameter string HitMode {
                    label {Hit Mode}
                    description {
                        Determines the opacity of the hit surface by examining the surface's
                        shade:transmissionhitmode attribute,
                        the primitive's Os vertex variable or Opacity attribute,
                        by running its shader to get the shaded opacity,
                        or by looking up the opacity cached in the point data file
                        specified by the shade:transmissionhitcache file attribute.
                    }
                    detail uniform
                    subtype selector
                    range {
                        "transmissionhitmode" default
                        "primitive"           primitive
                        "shader"              shader
                        "cache"               cache
                    }
                    default default
                }

                parameter string HitSides {
                    label {Hit Sides}
                    description {
                        Specifies which side(s) of surfaces can be hit by the shadow rays.
                    }
                    detail uniform
                    subtype selector
                    range {
                        "Front" front
                        "Back" back
                        "Front & Back" both
                    }
                    default front
                }
            }

            collection void ShadowMapControls {
                label {Shadow Map Controls}
                display hidden

                collection customuiFullWidth ShdFiles {
                    display hidden
                    customui laika AddParam
                    subtype propertycreator
                    drawmode children
                    state open
                    userdata {
                        AddString "Add AreaShadow File"
                        AddDescription "AreaShadow Deep Shadow Files added here will\nbe used to compute the shadow."
                        ParamType string
                        ParamSubtype file
                        ParamPrefix dtexFile
                        ParamLabel File
                        ParamDescription "The name of an AreaShadow deep shadow file. You can also use a tcl command such as [PassFileName rmanPassName] to refer to the file generated by a render pass."
                        ParamProvider variable
                        ParamDetail varying
                        ParamDefault {}
                    }
                }

                parameter float MapBias {
                    display hidden
                    label {Map Bias}
                    description {
                        Scales an automatically computed bias value when using AreaShadow Files.
                        In most cases the default value of 1 should be appropriate.
                    }
                    detail uniform
                    subtype slider
                    range {.5 2}
                    default 1
                }

                parameter float LeakBias {
                    display hidden
                    label {Leak Bias}
                    description {
                        Helps to control light leaks from AreaShadow Files.
                        With values above 0, each texel in the map will contribute
                        to the total shadowing using a slightly broader depth interval.
                        This can mitigate cases of aliasing on geometry seen obliquely
                        from the shadow generation camera. Typical values are 1 to 5.
                    }
                    detail uniform
                    subtype slider
                    range {0 5}
                    default 3.5
                }
            }
        }

        collection customuiFullWidth AOVs {
            customui laika AddParam
            subtype propertycreator
            drawmode children
            state open
            userdata {
                AddString   "Add AOV"
                AddDescription "Allows you to add an Arbitrary Output Variable."
                ParamType   AOV
                ParamPrefix AOV
                ParamDetail {mustvary "laika,AOV" inline}
            }
        }

        collection shader(0) __boundcoshaders {
            display hidden
            label {Bound Coshaders}
            description {
                Coshaders entered here will become known to the light so it can process them.
            }
            provider primitive

            parameter shader __boundcoshaders:0 {
                provider primitive
                default {}
                index 0
            }
        }

        RSLInclude {stdrsl/AreaSampler.h}
        RSLInclude {stdrsl/RadianceSample.h}

        RSLInclude {coreV7/rayinfo.h}
        RSLInclude {coreV7/optsandattrs.h}
        RSLInclude {coreV7/radianceSample.h}
        RSLInclude {coreV7/light.h}


        RSLInclude {sl.h}
        RSLInclude {math.h}
        RSLInclude {color.h}


        RSLClass {
output "
            // Global variables.

            private light_s         _light;
            private rayinfo_s       rayinfoData;
            private optsandattrs_s  optsandattrsData;

            // References an extern rayinfoData variable.
            #include <coreV7/sampleSize.h>

            // Global variables.
            private varying color   lightCI;    // color*intensity
            private varying float   lightIntensity;
            private uniform float   areashadowbias;

            private uniform shader  radianceEffectors\[\], shadowEffectors\[\];

            private constant string _dtexFiles\[\] = {};
            private constant float  _raytrace = 0;

            private uniform float   numSamples;
            private uniform matrix  envMatrix;

            // Override variables.
            private varying float   _Enable;
            private varying float   _Intensity;
            private uniform string  _EnvMap;
            private varying float   _Exposure;
            private varying color   _Color;
            private varying color   _DiffuseTint;
            private varying float   _DiffuseIntensity;
            private varying color   _DiffuseColor;
            private varying color   _SpecularTint;
            private varying float   _SpecularIntensity;
            private varying color   _SpecularColor;
            private uniform float   _Samples;
            private uniform float   _DepthReduction;
            private uniform float   _TraceBias;
            private uniform float   _MapBias;
            private uniform float   _LeakBias;
            private varying float   _Adaptive;
            private varying float   _MaxDist;
            private varying float   _ShadowEnable;
            private varying color   _ShadowColor;
            private uniform string  _IncludeSet;
            private uniform string  _ExcludeSet;
            private uniform string  _HitMode;
            private uniform string  _HitSides;
"

            generateMethod "public void construct()" {
                generate ShadowMethod
output "
                if ([getvar ShadowMethod] != \"AreaShadow\") _raytrace = 1;

                if ([getvar ShadowMethod] != \"Raytrace\")
                {
"
                    set dtexFileList [getproperties -name dtexFile_* -access input]
                    foreach dtexFile $dtexFileList {
                        generate $dtexFile
output "
                        if ([getvar $dtexFile] != \"\")
                        {
                            push( _dtexFiles, [getvar $dtexFile] );
                        }
" 
                    }
output "
                }
"
            }

            generateMethod "public void begin()" {

                generate -dtexFile_* -ShadowMethod
output "
                extern light_s          _light;
                extern rayinfo_s        rayinfoData;
                extern optsandattrs_s   optsandattrsData;

                _light->begin();
                rayinfoData->Init();
                optsandattrsData->Init();

                uniform float   depth = rayinfoData->depth;
                varying float   importance = rayinfoData->importance;

                // Determine the light's Enable status for the surface currently being lit.
                _Enable = [getvar Enable];

                // Get the lighteffector coshaders.
                uniform string  categoryUser\[\] = split( __categoryUser, \",\" );

                getEffectorList( \"ikaRadianceEffector\", categoryUser, __boundcoshaders, radianceEffectors );
                getEffectorList( \"ikaShadowEffector\", categoryUser, __boundcoshaders, shadowEffectors );

                _Color = [getvar Color];
                _Intensity = [getvar Intensity];
                _EnvMap = [getvar EnvFile];
                _Exposure = [getvar Exposure];
                _DiffuseTint = [getvar DiffuseTint];
                _DiffuseIntensity = [getvar DiffuseIntensity];
                _SpecularTint = [getvar SpecularTint];
                _SpecularIntensity = [getvar SpecularIntensity];
                _Samples = [getvar Samples];
                _DepthReduction = [getvar DepthReduction];
                _MapBias = [getvar MapBias];
                _LeakBias = [getvar LeakBias];
                _ShadowEnable = [getvar ShadowEnable];
                _ShadowColor = [getvar ShadowColor];
                _IncludeSet = [getvar IncludeSet];
                _ExcludeSet = [getvar ExcludeSet];
                _HitMode = [getvar HitMode];
                _HitSides = [getvar HitSides];

                if ([getvar TraceBias] != -1)
                {
                    _TraceBias = [getvar TraceBias];
                }
                else
                {
                    uniform float   tracebias = 0.01;
                    attribute( \"trace:bias\", tracebias );

                    if (attribute( \"user:areashadowbias\", _TraceBias ) == 0) _TraceBias = tracebias;
                }

                // Determine the MaxDist.
                // -1 signifies infinity.
                _MaxDist = [getvar MaxDist];
                if (_MaxDist == -1) _MaxDist = MAXDIST;

                _DiffuseColor = colorSRGBToLinear( _DiffuseTint * _DiffuseIntensity );
                _SpecularColor = colorSRGBToLinear( _SpecularTint * _SpecularIntensity );

                uniform float   EnvMapExists, dummy;
                EnvMapExists = textureinfo( _EnvMap, \"exists\", dummy );

                if (_EnvMap != \"\" && EnvMapExists == 0)
                {
                    printf( \"ERROR: %s EnvMap %s does not exist. \", __FILE__, _EnvMap );
                }

                if (_Samples < 0) _Samples = optsandattrsData->env_density;

                if ([getvar ColorMode] == \"sRGB\") _Color = colorSRGBToLinear (_Color);

                lightCI = colorSRGBToLinear( _Intensity * _Enable ) * pow( 2,_Exposure ) * _Color;

                envMatrix = transform ( [getvar EnvSpace], matrix 1 );

                // Katana environment orientation matching transform.
                envMatrix = rotate( envMatrix, HALFPI, vector(1,0,0) );
                envMatrix = rotate( envMatrix, HALFPI, vector(0,0,1) );
"
            }

            generateMethod "public void light (output vector L; output color Cl)" {
output "
                L = vector 0;
                Cl = lightCI;
"
            }


            generateMethod "private varying color stageAndRadianceTint()" {
output "
                extern light_s  _light;
                extern shader   radianceEffectors\[\];

                varying color   diffspecColor;

                // Accumulate radiance effects (which are sample-independent) to apply to the light color.
                varying color   radianceEffects = accumulateRadianceEffects( radianceEffectors, _light );

                // Adjust color based on the response type settings.
                uniform string  pipelinestage;
                shaderinfo(\"pipelinestage\", pipelinestage);

                diffspecColor = color 1;

                if (pipelinestage == \"diffuselighting\")
                    diffspecColor = _DiffuseColor;

                else if (pipelinestage == \"specularlighting\")
                    diffspecColor = _SpecularColor;

                return (diffspecColor * radianceEffects);
"
            }


            generateMethod "public void generateSamples (string integrationdomain; output __radiancesample samples\[\])" {
output "
                varying color   tint = stageAndRadianceTint();

                sampleSize_s    sampleSize;
                uniform float   numSamples = sampleSize->Light( _Samples, \"env\", 1, P, vector N );

                generateSamplesEnv( _EnvMap, P, N, numSamples, samples,
                    \"environmentspace\", envMatrix, 
                    \"distribution\", [getvar Distribution], 
                    \"radius\", _MaxDist, 
                    \"scale\", lightCI * tint,
                    \"integrationdomain\", integrationdomain
                );
"
            }

            generateMethod "public void evaluateSamples (string integrationdomain; output __radiancesample samples\[\])" {
output "
                varying color   tint = stageAndRadianceTint();

                evaluateSamplesEnv( _EnvMap, P, N, samples,
                    \"environmentspace\", envMatrix, 
                    \"distribution\", [getvar Distribution], 
                    \"radius\", _MaxDist, 
                    \"scale\", lightCI * tint,
                    \"integrationdomain\", integrationdomain
                );
"
            }

            generateMethod "public void shadowSamples (output __radiancesample samples\[\])" {
output "
                filterregion    fr;
                fr->calculate3d( Ps );

                varying color   lightVisibility;
                varying color   lightTransmission;

                if (gridever( _ShadowEnable > 0 ))
                {
                    lightTransmission = color 1 - areashadow( _dtexFiles, fr, samples,
                        \"raytrace\", _raytrace,
                        \"adaptive\", _Adaptive,
                        \"subset\", _IncludeSet,
                        \"excludesubset\", _ExcludeSet,
                        \"bias\", _TraceBias,
                        \"mapbias\", _MapBias,
                        \"mapbias2\", _LeakBias,
                        \"hitmode\", _HitMode,
                        \"hitsides\", _HitSides,
                        \"maxdist\", _MaxDist
                    );

                    uniform float   i, numSamples = arraylength( samples );
                    for (i=0; i < numSamples; i+=1)
                    {
                        lightVisibility = mix( color 1, samples\[i\]->lightVisibility, _ShadowEnable );
                        samples\[i\]->lightVisibility = mix( _ShadowColor, color 1, lightVisibility );
                    }
"
                    set shadowAOV [getproperties -name ShadowAOV]
output "
                    if ([getvar $shadowAOV] != \"\") writeaov( [getvar $shadowAOV], lightTransmission );
                }
                else
                {
                    setLightVisibility( color 1, samples );
                }

                // Apply shadow (sample-dependent) effectors.
                applyShadowEffects( shadowEffectors, _light, samples );
"
            }
        }
    }

  }
}
